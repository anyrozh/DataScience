# -*- coding: utf-8 -*-
"""ML: DEMAND FORECAST-part2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HjMHTB9xhPBI1AJBb4QjT7r6TR_YsVf5

**Feature Engineering**

**простая агрегированная статистика qty не может быть полноценно использована в качестве признака или таргета для модели.** Если у нас есть только информация об активности товара за сегодняшний день, это мало что говорит о том, что будет с этим товаром завтра или через неделю.

Нам необходимо более эффективно использовать имеющуюся историческую информацию.

Как посчитать нужные нам признаки и целевые переменные?
Оконная функция .rolling() в pandas создает "скользящее окно" строк в датафрейме, к которому затем можно применять другие методы. Все последующие методы, такие как сумма или среднее, работают уже с этим окном, выполняя вычисления для каждого подмножества данных. **Цепочки методов в pandas** – это **последовательный вызов различных методов над датафреймом**, где результат одного метода передается следующему методу в цепочке.

Для каждой строки датасета (строка — это товар-день) в качестве признаков мы рассчитаем:

1. среднее количество продаж за последние N дней,
2. Квантиль X продаж за последние N дней.

Для каждой строки датасета (строка — это товар-день) в качестве признаков мы рассчитаем:

1. среднее количество продаж за последние N дней,
2. Квантиль X продаж за последние N дней.
В качестве таргетов мы рассчитаем:

1. суммарное количество продаж за следующие N дней.

**add_features** – добавляет в DataFrame новые признаки, вычисленные по методу скользящего окна для каждого sku_id за последние N дней.

**add_targets** – добавляет в DataFrame новые целевые переменные, рассчитанные как сумма следующих N дней для каждого sku_id, исключая текущий день.

1. **qty_7d_avg, qty_14d_avg, qty_21d_avg**– среднее количество продаж за предыдущие 1, 2 и 3 недели, включая сегодняшний день.
2. **qty_7d_q10, qty_7d_q50, qty_7d_q90** (аналогично 14d, 21d) – **квантили 0.1, 0.5, 0.9 продаж за предыдущие 1, 2, 3 недели.**
3. **next_7d, next_14d, next_21d** – суммарное количество продаж за следующие 1, 2, 3 недели, не включая сегодняшний день (таргеты).
"""

FEATURES = {
    "qty_7d_avg": ("qty", 7, "avg", None),
    "qty_7d_q10": ("qty", 7, "quantile", 10),
    "qty_7d_q50": ("qty", 7, "quantile", 50),
    "qty_7d_q90": ("qty", 7, "quantile", 90),
    "qty_14d_avg": ("qty", 14, "avg", None),
    "qty_14d_q10": ("qty", 14, "quantile", 10),
    "qty_14d_q50": ("qty", 14, "quantile", 50),
    "qty_14d_q90": ("qty", 14, "quantile", 90),
    "qty_21d_avg": ("qty", 21, "avg", None),
    "qty_21d_q10": ("qty", 21, "quantile", 10),
    "qty_21d_q50": ("qty", 21, "quantile", 50),
    "qty_21d_q90": ("qty", 21, "quantile", 90),
}

TARGETS = {
    #"next_2d": ("qty", 2),
    "next_7d": ("qty", 7),
    "next_14d": ("qty", 14),
    "next_21d": ("qty", 21),
}

import pandas as pd
from typing import Dict, Tuple, Optional


def add_features(
    df: pd.DataFrame,
    features: Dict[str, Tuple[str, int, str, Optional[int]]],
) -> None:
    """
    Add rolling features to the DataFrame based on the specified aggregations.
    For each sku_id, the features are computed as the aggregations of the last N-days.
    Current date is always included into rolling window.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame to add the feature to. Changes are applied inplace.
    features : Dict[str, Tuple[str, int, str, Optional[int]]]
        Dictionary with the following structure:
        {
            "feature_name": ("agg_col", "days", "aggregation_function", "quantile"),
            ...
        }
        where:
            - feature_name: name of the feature to add
            - agg_col: name of the column to aggregate
            - int: number of days to include into rolling window
            - aggregation_function: one of the following: "quantile", "avg"
            - int: quantile to compute (only for "quantile" aggregation_function)

    Raises
    ------
    ValueError
        If aggregation_function is not one of the following: "quantile", "avg"
    """
    for feature_name, (agg_col, days, agg_func, quantile) in features.items():
        if agg_func == "quantile":
            df[feature_name] = (
                df.groupby("sku_id")[agg_col]
                .rolling(window=days)
                .quantile(quantile / 100)
                .reset_index(level=0, drop=True)
            )
        elif agg_func == "avg":
            df[feature_name] = (
                df.groupby("sku_id")[agg_col]
                .rolling(window=days)
                .mean()
                .reset_index(level=0, drop=True)
            )
        else:
            raise ValueError(f"Unknown aggregation function: {agg_func}")

def add_targets(df: pd.DataFrame, targets: Dict[str, Tuple[str, int]]) -> None:
    df.sort_values(['sku_id', 'day'], inplace=True)
    for target_name, (agg_col, days) in targets.items():
        res = (
            df.groupby("sku_id")[agg_col]
              .shift(-1)
              .rolling(window=days, min_periods=days)
              .sum()
              .shift(-(days - 1))  # <-- тут магия!
              .reset_index(level=0, drop=True)
        )
        df[target_name] = res

def add_targets(df: pd.DataFrame, targets: Dict[str, Tuple[str, int]]) -> None:
    df.sort_values(['sku_id', 'day'], inplace=True)
    for target_name, (agg_col, days) in targets.items():
        res = (
            df.groupby("sku_id")[agg_col]
              .shift(-1)
              .rolling(window=days, min_periods=days)
              .sum()
              .shift(-(days - 1))  # <-- тут магия!
              .reset_index(level=0, drop=True)
        )
        df[target_name] = res

df = pd.read_csv('/content/query.csv')
df

import time
start = time.time()
add_targets(df,TARGETS)
add_features(df,FEATURES)
end = time.time()
print(f"Время выполнения: {end} сек")

df.to_csv('features.csv', index=False)

"""Задача регрессии, когда необходимо предсказывать не средние значения таргета, а квантили, называется квантильной регрессией."""

import pandas as pd
df = pd.read_csv('/content/features.csv')
df

import pandas as pd
from typing import List, Tuple, Dict
import numpy as np
import pandas as pd
from sklearn.linear_model import QuantileRegressor
from tqdm import tqdm

def split_train_test(
    df: pd.DataFrame,
    test_days: int = 30,
) -> Tuple[pd.DataFrame, pd.DataFrame]:
    df = df.copy()
    df = df.dropna()
    max_day = df["day"].max()
    split_day = max_day - pd.Timedelta(days=(test_days+1))
    df_test = df[df["day"] > split_day]
    df_train = df[df["day"] <= split_day]
    return df_train, df_test

class MultiTargetModel:
    def __init__(
        self,
        features: List[str],
        horizons: List[int] = [7, 14, 21],
        quantiles: List[float] = [0.1, 0.5, 0.9],
    ) -> None:
        self.quantiles = quantiles
        self.horizons = horizons
        self.sku_col = "sku_id"
        self.date_col = "day"
        self.features = features
        self.targets = [f"next_{horizon}d" for horizon in self.horizons]
        self.fitted_models_ = {}

    def fit(self, data: pd.DataFrame, verbose: bool = False) -> None:
        """Fit model on data."""
        sku_ids = data[self.sku_col].unique()

        iterable = tqdm(sku_ids) if verbose else sku_ids

        for sku_id in iterable:
            sku_data = data[data[self.sku_col] == sku_id]
            if len(sku_data) == 0:
                continue

            self.fitted_models_[sku_id] = {}

            X = sku_data[self.features].values
            for horizon in self.horizons:
                y = sku_data[f"next_{horizon}d"].values

                for quantile in self.quantiles:
                    model = QuantileRegressor(
                        quantile=quantile,
                        alpha=1.0,
                        solver='highs'
                    )
                    model.fit(X, y)
                    self.fitted_models_[sku_id][(quantile, horizon)] = model

    def predict(self, data: pd.DataFrame) -> pd.DataFrame:
        """Predict on data."""
        predictions = data[[self.sku_col, self.date_col]].copy()

        # Initialize all prediction columns with 0
        for horizon in self.horizons:
            for quantile in self.quantiles:
                predictions[f"pred_{horizon}d_q{int(quantile*100)}"] = 0.0

        # Make predictions for known SKUs
        for sku_id in data[self.sku_col].unique():
            if sku_id in self.fitted_models_:
                sku_data = data[data[self.sku_col] == sku_id]
                X = sku_data[self.features].values

                for (quantile, horizon), model in self.fitted_models_[sku_id].items():
                    pred_col = f"pred_{horizon}d_q{int(quantile*100)}"
                    predictions.loc[predictions[self.sku_col] == sku_id, pred_col] = model.predict(X)

        return predictions

def quantile_loss(y_true: np.ndarray, y_pred: np.ndarray, quantile: float) -> float:
    """
    Calculate the quantile loss between the true and predicted values.
    """
    errors = y_true - y_pred
    loss = np.mean(np.maximum(quantile * errors, (quantile - 1) * errors))
    return loss

"""Разделить датасет на train и test (30 последних дней)
(простое разделение без кросс-валидации)

Для каждого sku:
    Для каждого горизонта планирования (1, 2, 3 недели):
        Для каждого квантиля (0.1, 0.5, 0.9):
            Обучить модель на train
            Сохранить модель в словарь

Для каждого sku:
    Для каждого горизонта планирования (1, 2, 3 недели):
        Для каждого квантиля (0.1, 0.5, 0.9):
            Сделать прогноз для test и сохранить результаты в датафрейм

Оценить качество модели с помощью метрики
"""

df['day'] = pd.to_datetime(df['day'])

df_train, df_test = split_train_test(df, test_days=30)

model = MultiTargetModel(
    features=[
        "price",
        "qty",
        "qty_7d_avg",
        "qty_7d_q10",
        "qty_7d_q50",
        "qty_7d_q90",
        "qty_14d_avg",
        "qty_14d_q10",
        "qty_14d_q50",
        "qty_14d_q90",
        "qty_21d_avg",
        "qty_21d_q10",
        "qty_21d_q50",
        "qty_21d_q90",
    ],
    horizons=[7, 14, 21],
    quantiles=[0.1, 0.5, 0.9],
)
model.fit(df_train, verbose=True)

predictions = model.predict(df_test)

predictions.columns

df.columns

import pandas as pd


def evaluate_model(
    df_true: pd.DataFrame,
    df_pred: pd.DataFrame,
    quantiles: List[float] = [0.1, 0.5, 0.9],
    horizons: List[int] = [7, 14, 21],
) -> pd.DataFrame:
    """Evaluate model on data.

    Parameters
    ----------
    df_true : pd.DataFrame
        True values.
    df_pred : pd.DataFrame
        Predicted values.
    quantiles : List[float], optional
        Quantiles to evaluate on, by default [0.1, 0.5, 0.9].
    horizons : List[int], optional
        Horizons to evaluate on, by default [7, 14, 21].

    Returns
    -------
    pd.DataFrame
        Evaluation results.
    """
    losses = {}

    for quantile in quantiles:
        for horizon in horizons:
            true = df_true[f"next_{horizon}d"].values
            pred = df_pred[f"pred_{horizon}d_q{int(quantile*100)}"].values
            loss = quantile_loss(true, pred, quantile)

            losses[(quantile, horizon)] = loss

    losses = pd.DataFrame(losses, index=["loss"]).T.reset_index()
    losses.columns = ["quantile", "horizon", "avg_quantile_loss"]  # type: ignore

    return losses

# df_test — это твои настоящие значения на тесте
# df_pred — это предсказания модели на этих объектах
result = evaluate_model(df_test, predictions)
result

"""**Бутстрэп (Bootstrap)** — это статистический метод, позволяющий оценить величину ошибки и уверенность в ней при использовании оценочных значений. С помощью бутсрэпа формируют доверительный интервал, который и является оценкой величины ошибки.

Наша задача заключается в том, чтобы 80% значений попали в доверительный интервал.
"""

df

import pandas as pd

def week_missed_profits(
    df: pd.DataFrame,
    sales_col: str,
    forecast_col: str,
    date_col: str = "day",
    price_col: str = "price",
) -> pd.DataFrame:
    """
    Calculates the missed profits every week for the given DataFrame.
    """
    # Для удобства преобразуем дату к неделе
    df = df.copy()
    df["week"] = pd.to_datetime(df[date_col]).dt.to_period("W-SUN").dt.end_time
    df["week"] = df["week"].dt.normalize()
    # Посчитаем missed_sold per row
    df["missed_sold"] = (df[forecast_col] - df[sales_col]).clip(lower=0)
    df["missed_profits"] = df["missed_sold"] * df[price_col]

    # revenue - реальная выручка
    df["revenue"] = df[sales_col] * df[price_col]

    # Группируем по неделям
    res = df.groupby("week").agg(
        revenue=("revenue", "sum"),
        missed_profits=("missed_profits", "sum")
    ).reset_index().rename(columns={"week": "day"})
    return res

df = df.dropna()

# Для 21 дня и квантиль 90
df_merged = pd.merge(
    df,
    predictions,
    on=['sku_id', 'day'],
    how='inner'
)

df_merged

"""1. 0.1 квантиль – "пессимистичный" прогноз (в 90% случаев прогноз ниже реальных продаж);
2. 0.5 квантиль – "консервативный" прогноз (в 50% случаев реальные продажи выше, в 50% ниже);
3. 0.9 квантиль – "оптимистичный" прогноз (в 90% прогноз окажется выше реальных продаж).
"""

df_merged.columns

"""#7 ДНЕЙ"""

missed_profit_pes7 = week_missed_profits(df=df_merged, sales_col='next_7d', forecast_col='pred_7d_q10', date_col='day', price_col='price')
missed_profit_pes7

missed_profit_bas7 = week_missed_profits(df=df_merged, sales_col='next_7d', forecast_col='pred_7d_q50', date_col='day', price_col='price')
missed_profit_bas7

missed_profit_opt7 = week_missed_profits(df=df_merged, sales_col='next_7d', forecast_col='pred_7d_q90', date_col='day', price_col='price')
missed_profit_opt7

"""#14 ДНЕЙ"""

#cуммарное количество продаж на 14 дней
missed_profit_pes14 = week_missed_profits(df=df_merged, sales_col='next_14d', forecast_col='pred_14d_q10', date_col='day', price_col='price')
missed_profit_pes14

"""# 21 ДЕНЬ"""

missed_profit_pes21 = week_missed_profits(df=df_merged, sales_col='next_21d', forecast_col='pred_21d_q10', date_col='day', price_col='price')
missed_profit_pes21

"""В отчет выводятся две оценки: в абсолютных и относительных величинах. Относительная величина считается относительно среднего значения фактической выручки в неделю.

1. Для каждой случайной выборки вычисляется среднее missed_profits и revenue
2. Строим доверительный интервал
"""

import numpy as np
from typing import Tuple

def missed_profits_ci(
    df: pd.DataFrame,
    missed_profits_col: str,
    confidence_level: float = 0.95,
    n_bootstraps: int = 1000,
) -> Tuple[Tuple[float, Tuple[float, float]], Tuple[float, Tuple[float, float]]]:
    """
    Estimates the missed profits for the given DataFrame.
    Calculates average missed_profits per week and estimates the confidence interval.
    """
    rng = np.random.default_rng()
    missed = df[missed_profits_col].values
    revenues = df["revenue"].values

    means_abs = []
    means_rel = []

    for _ in range(n_bootstraps):
        idx = rng.integers(0, len(df), len(df))
        boot_missed = missed[idx]
        boot_revenue = revenues[idx]
        mean_missed = boot_missed.mean()
        mean_revenue = boot_revenue.mean()
        means_abs.append(mean_missed)
        means_rel.append(mean_missed / mean_revenue if mean_revenue > 0 else np.nan)

    # Центральная оценка по исходным данным
    mean_abs = missed.mean()
    mean_rel = mean_abs / revenues.mean()

    # доверительный интервал
    alpha = (1 - confidence_level) / 2
    lower = int(n_bootstraps * alpha)
    upper = int(n_bootstraps * (1 - alpha))

    abs_ci = np.sort(means_abs)[[lower, upper]]
    rel_ci = np.sort(means_rel)[[lower, upper]]

    # Привести к tuple с немагическими числами
    return (
        (mean_abs, (abs_ci[0], abs_ci[1])),
        (mean_rel, (rel_ci[0], rel_ci[1])),
    )

"""**В 90% случаев фактические продажи выше этого прогноза**"""

import numpy as np
ci = missed_profits_ci(missed_profit_pes7, 'missed_profits')
print('Среднее упущенной прибыли за неделю:', ci[0][0])
print('Доверительный интервал (абс):', ci[0][1])
print('Среднее % упущенной прибыли по выручке:', ci[1][0])
print('Доверительный интервал (отн):', ci[1][1])

"""В 50% случаев продажи выше прогноза.
В 50% случаев – ниже.
"""

import numpy as np
ci = missed_profits_ci(missed_profit_bas7, 'missed_profits')
print('Среднее упущенной прибыли за неделю:', ci[0][0])
print('Доверительный интервал (абс):', ci[0][1])
print('Среднее % упущенной прибыли по выручке:', ci[1][0])
print('Доверительный интервал (отн):', ci[1][1])

"""**В 90% случаев фактические продажи ниже этого прогноза.
В 10% случаев продажи превышают прогноз (лучший сценарий).**
"""

import numpy as np
ci = missed_profits_ci(missed_profit_opt7, 'missed_profits')
print('Среднее упущенной прибыли за неделю:', ci[0][0])
print('Доверительный интервал (абс):', ci[0][1])
print('Среднее % упущенной прибыли по выручке:', ci[1][0])
print('Доверительный интервал (отн):', ci[1][1])

"""**Training Pipeline**

{
  # Анна Рожкова's workspace
  web_server: https://app.clear.ml/
  api_server: https://api.clear.ml
  files_server: https://files.clear.ml
  credentials {
    "access_key" = "IZH03SVDDS1XFN0RQN8A3EZ3OKUWXN"
    "secret_key" = "uD9fSEidYd90kyJr9llA8x1uZXG1Akl_IGfeFRVNfviNrcq4I1gRVxCXOLZMrkJctqM"
  }
}

## 2 ЧАСТЬ

мы должны определить, какие товары следует закупить и в каком количестве, чтобы получить наибольшую выгоду в зависимости от выбранной стратегии — будь то получение максимальной прибыли с каждой продажи или увеличение общего объема выручки.

Таким образом нам необходимо придумать стратегию **закупки товаров в рамках определенного бюджета, которая учитывает все эти факторы:**

1. **Прогнозы спроса:** Сколько товара закупить, чтобы не рисковать нехваткой.
2. **Прибыльность и стоимость:** Какие товары принесут наибольшую выгоду в рамках нашего бюджета.
3. **Срок хранения:** Как избежать излишков, которые могут испортиться и привести к потерям.
4. **Текущие запасы:** Как оптимизировать закупки, принимая во внимание уже имеющиеся на складе товары, чтобы не увеличивать излишки и не снижать оборачиваемость.

Эта стратегия позволит нам эффективно управлять бюджетом, избегая как излишков, так и недостатков, с максимальной выгодой для компании.

У нас есть список товаров и прцентили прогнозов спроса - как же выбрать товар с которого начать закупку?

Давайте придумаем количественный показатель, который будет отражать ценность каждого товара в различных сценариях: максимизации прибыли или максимизации выручки. **Этот показатель должен учитывать не только потенциал прибыли или выручки от продажи товара, но и риски, связанные с его хранением, а также текущие запасы этого товара на складе.** Отсортировав наши товары по убыванию этого показателя - мы получим в начале списка наиболее ценные для закупки товары. Рассмотрим расчет этого показателя для обоих сценариев - **максимизаций прибыли или выручки**
"""



"""![profit.png](data:image/png;base64,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)

**первый множитель:** позволяет сравнивать товары по их рентабельности

**OOS Risk:** *Риск получить нехватку товара* (out of stock), считается как 1 - процентиль прогноза / 100, **чем выше выбранный процентиль тем ниже риск потенциальной нехватки товара и наоборот.**

**log(StorageTime)** - коэффициент срока хранения, десятичный логарифм помогает сгладить разницу в масштабах сроков хранения для разных продуктов. Чем выше срок хранения товаров - тем более он ценный для нас.
"""

import math

price = 317
cost = 288
current_stock = 22
storage_time = 76
percentiles = {"5": 9, "10": 10, "25": 22, "50": 28, "75": 31, "90": 37, "95": 43}  # 2w

for prc, demand in percentiles.items():
    demand_to_buy = max(0, demand - current_stock)
    expected_profit = (price - cost) * demand_to_buy

    oos_risk = 1 - int(prc) / 100.0
    profit_score = ((price - cost) / cost) * oos_risk * math.log10(storage_time)

    if demand_to_buy > 0:
        print(f"percentile: {prc}, profit score: {profit_score:0.2f}, expected profit: {expected_profit}")

"""**Жадный алгоритм**

Этот подход называется жадным, потому что в каждый момент времени он выбирает то, что кажется наилучшим решением, не оглядываясь на последствия. **В нашем случае жадный алгоритм будет поочередно выбирать товары для закупки, начиная с тех, которые приносят максимальную выгоду (будь то прибыль или выручка), пока не исчерпается бюджет.**

1. Для каждого товара и каждого процентиля прогноза спроса рассчитываем необходимые показатели: **сколько нужно закупить, ожидаемую прибыль, выручку и другие параметры**
2. Вычисляем **количественный показатель (score) для каждого товара либо на основе прибыли, либо на основе выручки**
3. Сортируем **товары по соответствующему показателю (score)**
4. **Последовательно распределяем бюджет, начиная с самых высоко оцененных товаров, пока не исчерпаем доступные средства**
5. Возвращаем два DataFrame: **один с отсортированными товарами**, другой с **итоговым распределением бюджета.**
"""

from typing import Tuple, List, Dict, Any
import math
import json
import os
import pandas as pd


class GreedyRestock:
    """
    A class to allocate a budget for restocking products using a greedy algorithm.
    """

    def __init__(self, json_path: str):
        """
        Initializes the GreedyRestock class by loading products from a JSON file.

        Args:
            json_path (str): The file path to the JSON file containing product data.

        Raises:
            FileNotFoundError: If the provided JSON file does not exist.
            ValueError: If the JSON data cannot be decoded or if the product list is empty.
            RuntimeError: If an unexpected error occurs while reading the JSON file.
        """
        if not os.path.isfile(json_path):
            raise FileNotFoundError(f"JSON file not found: {json_path}")
        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                self.products = json.load(f)
        except json.JSONDecodeError:
            raise ValueError("JSON data not decoded or is invalid.")
        except Exception as e:
            raise RuntimeError(f"Unexpected error while reading the JSON file: {e}")

        if not self.products or not isinstance(self.products, list):
            raise ValueError("Empty or invalid product list in JSON.")

        self._validate()

    def _validate(self):
        """
        Validates the structure and data of the products loaded from the JSON file.

        Raises:
            ValueError: If any required keys are missing, or if any numeric values
                        (price, cost, current stock, storage time) are invalid according to the rules above.
        """
        PCT_REQUIRED = {'5', '10', '25', '50', '75', '90', '95'}
        WEEKS_REQUIRED = {'1w', '2w', '3w', '4w'}

        for idx, prod in enumerate(self.products):
            for key in ['sku_id', 'price', 'cost', 'current_stock', 'storage_time', 'percentiles']:
                if key not in prod:
                    raise ValueError(f"Missing key {key} in product at index {idx}")

            # Numbers:
            try:
                price, cost, current_stock, storage_time = (
                    prod['price'], prod['cost'], prod['current_stock'], prod['storage_time']
                )
            except Exception:
                raise ValueError(f"Invalid numbers in product at index {idx}")

            if not (isinstance(price, (int, float)) and price > 0):
                raise ValueError(f"Invalid price in product at {idx}")
            if not (isinstance(cost, (int, float)) and cost > 0):
                raise ValueError(f"Invalid cost in product at {idx}")
            if price < cost:
                raise ValueError(f"Price less than cost in product at {idx}")
            if not (isinstance(current_stock, (int, float)) and current_stock >= 0):
                raise ValueError(f"Invalid current_stock in product at {idx}")
            if not (isinstance(storage_time, (int, float)) and storage_time > 0):
                raise ValueError(f"Invalid storage_time in product at {idx}")

            percentiles = prod['percentiles']
            if not (isinstance(percentiles, dict) and all(week in percentiles for week in WEEKS_REQUIRED)):
                raise ValueError(f"Missing week keys in percentiles at {idx}")

            for week, dct in percentiles.items():
                if not (isinstance(dct, dict) and all(str(pct) in dct for pct in PCT_REQUIRED)):
                    raise ValueError(f"Missing percentile keys in week {week} at product {idx}")

    def allocate(
        self, budget: int, weeks: int, optimization_goal: str = "profit"
    ) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Allocates a budget for restocking products based on a greedy algorithm.

        Returns (see prompt for details)
        """
        if not (isinstance(budget, int) and budget > 0):
            raise ValueError("budget must be positive integer")
        if weeks not in {1, 2, 3, 4}:
            raise ValueError("weeks must be 1, 2, 3, or 4")
        if optimization_goal not in {"profit", "revenue"}:
            raise ValueError("optimization_goal must be 'profit' or 'revenue'")

        week_key = f"{weeks}w"
        percentile_list = ['5', '10', '25', '50', '75', '90', '95']
        records = []

        for prod in self.products:
            sku_id = prod['sku_id']
            price = prod['price']
            cost = prod['cost']
            current_stock = prod['current_stock']
            storage_time = prod['storage_time']
            percentiles = prod['percentiles'][week_key]
            storage_score = math.log10(storage_time)
            for pct in percentile_list:
                demand = int(percentiles[pct])
                demand_to_buy = max(0, demand - current_stock)
                if demand_to_buy <= 0:
                    continue
                oos_risk = 1 - int(pct) / 100.0
                tot_cost = int(demand_to_buy * cost)
                tot_profit = int((price - cost) * demand_to_buy)
                tot_revenue = int(price * demand_to_buy)
                # profit_score
                if cost == 0:
                    profit_score = 0.0
                    revenue_score = 0.0
                else:
                   profit_score = ((price - cost) / cost) * oos_risk * storage_score
                   revenue_score = (price / cost) * demand_to_buy * oos_risk * storage_score

                records.append({
                    'sku_id': sku_id,
                    'percentile': int(pct),
                    'demand_to_buy': int(demand_to_buy),
                    'price': int(price),
                    'cost': int(cost),
                    'tot_profit': int(tot_profit),
                    'tot_revenue': int(tot_revenue),
                    'tot_cost': int(tot_cost),
                    'storage_score': float(storage_score),
                    'oos_risk': float(oos_risk),
                    'profit_score': float(profit_score),
                    'revenue_score': float(revenue_score)
                })

        col_order = [
            'sku_id', 'percentile', 'demand_to_buy', 'price', 'cost', 'tot_profit', 'tot_revenue', 'tot_cost',
            'storage_score', 'oos_risk', 'profit_score', 'revenue_score'
        ]
        if not records:
            # Если не найдено подходящих для закупки товаров
            sorted_df = pd.DataFrame([], columns=col_order)
            allocation_df = pd.DataFrame([], columns=["sku_id","percentile","price","cost",
                                                      "allocated_qty","allocated_budget","expected_profit","expected_revenue"])
            return sorted_df, allocation_df

        sorted_df = pd.DataFrame(records)[col_order]

        # Сортируем по score, потом по sku_id
        primary_score = "profit_score" if optimization_goal == "profit" else "revenue_score"
        sorted_df = sorted_df.sort_values(
            by=[primary_score, 'sku_id'], ascending=[False, True]
        )
        # Для allocation_df: берем по одной лучшей записи на sku_id (наивысший score)
        best_records = []
        used_sku = set()
        for ix, row in sorted_df.iterrows():
            sku = row['sku_id']
            if sku not in used_sku:
                best_records.append((ix, row))
                used_sku.add(sku)

        allocation_rows = []
        spent = 0
        for ix, row in best_records:
            need_qty = int(row['demand_to_buy'])
            cost1 = int(row['cost'])
            total_cost = cost1 * need_qty
            # Если не хватает бюджета, покупаем по максимуму на остаток
            if total_cost + spent > budget:
                possible_qty = int((budget - spent) // cost1) if cost1 > 0 else 0
                if possible_qty <= 0:
                    continue  # бюджет исчерпан, не добавляем
                total_cost = possible_qty * cost1
                allocated_qty = possible_qty
            else:
                allocated_qty = need_qty
            if allocated_qty > 0:
                rowdict = dict()
                rowdict['sku_id'] = row['sku_id']
                rowdict['percentile'] = int(row['percentile'])
                rowdict['price'] = int(row['price'])
                rowdict['cost'] = int(row['cost'])
                rowdict['allocated_qty'] = int(allocated_qty)
                rowdict['allocated_budget'] = int(total_cost)
                rowdict['expected_profit'] = int((row['price'] - row['cost']) * allocated_qty)
                rowdict['expected_revenue'] = int(row['price'] * allocated_qty)
                allocation_rows.append(rowdict)
                spent += total_cost
            if spent >= budget:
                break

        # Сортируем allocation_df как требуется:
        allocation_df = pd.DataFrame(
            allocation_rows,
            columns=["sku_id","percentile","price","cost",
                     "allocated_qty","allocated_budget","expected_profit","expected_revenue"]
        )

        allocation_df = allocation_df.sort_values(
            by=["allocated_budget", "sku_id"], ascending=[False, True]
        ) # Без reset_index

        return sorted_df, allocation_df

from tabulate import tabulate

products = [
    {
        "sku_id": "0001",
        "price": 317,
        "cost": 288,
        "current_stock": 22,
        "storage_time": 76,
        "percentiles": {
            "1w": {"5": 3, "10": 9, "25": 16, "50": 19, "75": 22, "90": 28, "95": 35},
            "2w": {"5": 9, "10": 10, "25": 22, "50": 28, "75": 31, "90": 37, "95": 43},
            "3w": {"5": 11, "10": 14, "25": 32, "50": 36, "75": 43, "90": 53, "95": 62},
            "4w": {"5": 12, "10": 24, "25": 33, "50": 46, "75": 53, "90": 60, "95": 71},
        },
    },
    {
        "sku_id": "0002",
        "price": 158,
        "cost": 143,
        "current_stock": 8,
        "storage_time": 65,
        "percentiles": {
            "1w": {"5": 6, "10": 7, "25": 9, "50": 19, "75": 23, "90": 25, "95": 32},
            "2w": {"5": 12, "10": 18, "25": 24, "50": 27, "75": 29, "90": 30, "95": 39},
            "3w": {"5": 17, "10": 24, "25": 34, "50": 37, "75": 47, "90": 54, "95": 62},
            "4w": {"5": 23, "10": 33, "25": 42, "50": 45, "75": 51, "90": 58, "95": 65},
        },
    },
]

gr = GreedyRestock("products.json")

gr.products = products

sorted_df, allocation_df = gr.allocate(2000, weeks=1, optimization_goal="profit")

print(tabulate(sorted_df, headers="keys", floatfmt="0.2f"))

print(tabulate(allocation_df, headers="keys", floatfmt="0.2f"))

total_cost = allocation_df["allocated_budget"].sum()
total_expected_profit = allocation_df["expected_profit"].sum()
print(f"\nОбщая сумма закупки: {total_cost}")
print(f"Общая ожидаемая прибыль: {total_expected_profit}")

### Output:

# Sorted df:
#   sku_id    percentile    demand_to_buy    price    cost    tot_profit    tot_revenue    tot_cost    storage_score    oos_risk    profit_score    revenue_score
# --------  ------------  ---------------  -------  ------  ------------  -------------  ----------  ---------------  ----------  --------------  ---------------
#     0002            25                1      158     143            15            158         143             1.81        0.75            0.14             1.50
#     0002            50               11      158     143           165           1738        1573             1.81        0.50            0.10            11.02
#     0002            75               15      158     143           225           2370        2145             1.81        0.25            0.05             7.51
#     0002            90               17      158     143           255           2686        2431             1.81        0.10            0.02             3.41
#     0001            90                6      317     288           174           1902        1728             1.88        0.10            0.02             1.24
#     0002            95               24      158     143           360           3792        3432             1.81        0.05            0.01             2.40
#     0001            95               13      317     288           377           4121        3744             1.88        0.05            0.01             1.35

# Allocation df:
#   sku_id    percentile    price    cost    allocated_qty    allocated_budget    expected_profit    expected_revenue
# --------  ------------  -------  ------  ---------------  ------------------  -----------------  ------------------
#     0001            90      317     288                6                1728                174                1902
#     0002            25      158     143                1                 143                 15                 158

# Общая сумма закупки: 1871
# Общая ожидаемая прибыль: 189

! pip install pulp

from typing import Tuple
import math
import pulp
import pandas as pd
from step2 import GreedyRestock


class LPRestock(GreedyRestock):
    def allocate(
        self, budget: int, weeks: int, optimization_goal: str = "profit"
    ) -> Tuple[pulp.LpProblem, pd.DataFrame]:
        """
        Allocates budget for restocking SKUs using linear programming to maximize either profit or revenue.

        Args:
            budget (int): The total budget available for restocking. Must be a positive integer greater than zero.
            weeks (int): The number of weeks to consider in the demand forecast, must be between 1 and 4.
            optimization_goal (str, optional): The objective of the optimization.
                                            Must be either 'profit' or 'revenue'. Defaults to 'profit'.

        Returns:
            Tuple[pulp.LpProblem, pd.DataFrame]:
                - pulp.LpProblem: The linear programming problem that was solved.
                - pd.DataFrame: A DataFrame containing the allocation results, including SKU ID,
                                allocated quantity, allocated budget, expected profit, and expected revenue.

        Raises:
            ValueError: If the budget is less than or equal to zero.
            ValueError: If the weeks parameter is not between 1 and 4, inclusive.
            ValueError: If the optimization_goal is not 'profit' or 'revenue'.

        Solver Information:
            The default solver is used for solving the linear programming problem.
            Simply calling the `.solve()` method on the `pulp.LpProblem` object is sufficient to
            perform the optimization.

        Coefficient Rounding:
            All coefficients used in the objective function are rounded to four decimal places.

        Variable Naming Conventions:
            - `decision_vars`: Decision variables represent the quantity of each SKU to be purchased.
                            They are named in the format `sku_<sku_id>_<percentile>`, where `<sku_id>`
                            is the identifier for the SKU and `<percentile>` corresponds to the demand
                            forecast percentile for the specified weeks.
            - `binary_vars`: Binary variables are used to ensure that only one combination of SKU and
                            percentile is selected. They are named similarly to decision variables,
                            prefixed with `bin_`, e.g., `bin_sku_<sku_id>_<percentile>`.

        Constraint Naming Conventions:
            - Budget constraint: Ensures the total cost of selected SKUs does not exceed the specified budget.
                Named `budget_constraint`.
            - SKU single selection constraint: Ensures only one percentile combination per SKU is selected.
                Named in the format `sku_<sku_id>_single_selection_constraint`.
            - Demand constraint: Ensures that the purchase quantity does not exceed the demand
                for the selected percentile. Named in the format `<decision_var_name>_demand_constraint`.

        `allocation_df` Structure:
            `allocation_df`: A DataFrame containing products selected for restocking, including the allocated quantities and expected outcomes.
                The structure of `allocation_df` is as follows:
                - `sku_id` (str): The SKU identifier of the product.
                - `percentile` (int): The percentile used for demand estimation.
                - `price` (int): The selling price of the product.
                - `cost` (int): The cost of the product.
                - `allocated_qty` (int): The quantity of the product allocated for purchase.
                - `allocated_budget` (int): The budget allocated to purchase the allocated quantity.
                - `expected_profit` (int): The expected profit from the allocated quantity.
                - `expected_revenue` (int): The expected revenue from the allocated quantity.

            The `allocation_df` DataFrame is sorted primarily by `allocated_budget` in descending order,
            and secondarily by `sku_id` in ascending order.
        """
        """
        Распределяет бюджет на пополнение ассортимента с помощью линейного программирования для максимизации прибыли или выручки.

        Аргументы:
            бюджет (int): Общий бюджет, доступный для пополнения запасов. Должно быть положительным целым числом, большим нуля.
            недели (int): Количество недель, учитываемое при прогнозировании спроса, должно быть от 1 до 4.
            optimization_goal (str, необязательно): Цель оптимизации.
                                            Должно быть либо "прибыль", либо "доход". По умолчанию используется значение "прибыль".

        Возвращается:
            Кортеж[pulp.lpпроблема, pd.DataFrame]:
                - pulp.Lpпроблема: задача линейного программирования, которая была решена.
                - pd.DataFrame: Фрейм данных, содержащий результаты распределения, включая идентификатор артикула,
                                выделенное количество, выделенный бюджет, ожидаемая прибыль и ожидаемый доход.

        Повышения:
            ValueError: Если бюджет меньше или равен нулю.
            ValueError: Если параметр "недели" не находится в диапазоне от 1 до 4 включительно.
            ValueError: Если целью оптимизации не является "прибыль" или "доход".

        Информация о решателе:
            Для решения задачи линейного программирования используется решатель по умолчанию.
            Просто вызовите метод ".solve()" в pulp.Объект LpProblem` достаточен для
            выполните оптимизацию.

        Округление коэффициентов:
            Все коэффициенты, используемые в целевой функции, округляются до четырех знаков после запятой.

        Правила присвоения имен переменным:
            - `decision_vars`: Переменные решения представляют количество каждого артикула, которое необходимо приобрести.
                            Они называются в формате "артикул_<идентификатор артикула>_<процентиль>", где "<идентификатор артикула>"
                            является идентификатором артикула, а "<процентиль>" соответствует спросу
                            прогнозируемый процентиль на указанные недели.
            - `binary_vars`: Двоичные переменные используются для обеспечения выбора только одной комбинации артикула и
            процентиля. Они называются аналогично переменным, принимающим решения, с префиксом `bin_`, например, `bin_sku_<идентификатор sku_id>_<процентиль>`.

        Соглашения об именовании ограничений:
            - Бюджетное ограничение: гарантирует, что общая стоимость выбранных артикулов не превысит указанный бюджет.
                Имя `budget_constraint`.
            - Ограничение выбора одного артикула: гарантирует, что для каждого артикула будет выбрано только одно процентильное сочетание.
                Указывается в формате `артикул_<идентификатор артикула>_single_selection_constraint`.
            - Ограничение спроса: гарантирует, что количество покупки не превысит спрос
                для выбранного процентиля. Имя в формате "<имя_варианта решения>_demand_constraint".

        Структура "allocation_df":
            "allocation_df": Фрейм данных, содержащий продукты, выбранные для пополнения запасов, включая выделенные количества и ожидаемые результаты.
                Структура `allocation_df` выглядит следующим образом:
                - `sku_id` (str): Идентификатор артикула продукта.
                - `Процентиль` (int): Процентиль, используемый для оценки спроса.
                - `цена" (int): Цена продажи продукта.
                - `стоимость` (int): Стоимость продукта.
                - `allocated_qty` (int): Количество товара, выделенное для покупки.
                - `allocated_budget` (int): Бюджет, выделенный для покупки выделенного количества.
                - `ожидаемая прибыль" (int): Ожидаемая прибыль от выделенного количества.
                - "ожидаемый доход" (int): Ожидаемый доход от выделенного количества.

            Фрейм данных "allocation_df" сортируется, в первую очередь, по "allocated_budget" в порядке убывания
            и, во вторую очередь, по "sku_id" в порядке возрастания.
            """

from typing import Tuple
import math
import pulp
import pandas as pd

class LPRestock(GreedyRestock):
    def allocate(
        self, budget: int, weeks: int, optimization_goal: str = "profit"
    ) -> Tuple[pulp.LpProblem, pd.DataFrame]:
        if not (isinstance(budget, int) and budget > 0):
            raise ValueError("budget must be positive integer")
        if weeks not in {1, 2, 3, 4}:
            raise ValueError("weeks must be 1, 2, 3, or 4")
        if optimization_goal not in {"profit", "revenue"}:
            raise ValueError("optimization_goal must be 'profit' or 'revenue'")

        week_key = f"{weeks}w"
        percentiles = ['5', '10', '25', '50', '75', '90', '95']

        # --- Собираем данные для LP задачи (аналогично Greedy) ---
        candidates = []  # Словари по всем подходящим к закупке вариантам

        for prod in self.products:
            sku_id = prod['sku_id']
            price = int(prod['price'])
            cost = int(prod['cost'])
            current_stock = int(prod['current_stock'])
            storage_time = float(prod['storage_time'])
            perc_dct = prod['percentiles'][week_key]

            storage_score = math.log10(storage_time)
            for pct in percentiles:
                demand = int(perc_dct[pct])
                demand_to_buy = max(0, demand - current_stock)
                if demand_to_buy <= 0:
                    continue
                oos_risk = 1 - int(pct) / 100.0
                tot_cost = demand_to_buy * cost
                tot_profit = (price - cost) * demand_to_buy
                tot_revenue = price * demand_to_buy
                # Индексы
                candidate = {
                    "sku_id": sku_id,
                    "percentile": int(pct),
                    "price": price,
                    "cost": cost,
                    "demand": demand,
                    "current_stock": current_stock,
                    "demand_to_buy": demand_to_buy,
                    "storage_score": storage_score,
                    "oos_risk": oos_risk,
                    "tot_profit": tot_profit,
                    "tot_revenue": tot_revenue,
                    "tot_cost": tot_cost,
                }
                # profit_score, revenue_score
                if cost == 0:
                    candidate["profit_score"] = 0.0
                    candidate["revenue_score"] = 0.0
                else:
                    candidate["profit_score"] = ((price - cost) / cost) * oos_risk * storage_score
                    candidate["revenue_score"] = (price / cost) * demand_to_buy * oos_risk * storage_score

                candidates.append(candidate)

        # Если нечего закупать – возвращаем все пустое (как в Greedy)
        if not candidates:
            cols = ["sku_id","percentile","price","cost",
                    "allocated_qty","allocated_budget","expected_profit","expected_revenue"]
            return pulp.LpProblem("LP_empty", pulp.LpMaximize), pd.DataFrame([], columns=cols)

        #Создает объект pulp.LpProblem для максимизации выбранной цели.
        prob = pulp.LpProblem("Restock_Optimization", pulp.LpMaximize)

        #Переменные - Это те переменные, значения которых мы хотим найти. Они представляют собой величины, которые мы можем контролировать или изменять в рамках задачи.:
        # 1) Решение: перем. qty и bin, а также быстрый доступ по sku_id,percentile
        #целочисленные переменные количества закупаемого товара
        qty_vars = {}
        #бинарные переменные выбора процентиля (0 или 1)
        bin_vars = {}

        # Убираем все варианты, где demand_to_buy <= 0 (заранее)
        filtered = [c for c in candidates if c["demand_to_buy"]> 0]

        for c in filtered:
            s = c["sku_id"]
            p = c["percentile"]
            var_name = f"sku_{s}_{p}"
            bin_name = f"bin_sku_{s}_{p}"

            # Решение: количество (0..demand_to_buy), целое
            qty_vars[(s, p)] = pulp.LpVariable(var_name, lowBound=0, upBound=c["demand_to_buy"], cat="Integer")
            # Бинарное: выбран ли этот вариант (0/1)
            bin_vars[(s, p)] = pulp.LpVariable(bin_name, lowBound=0, upBound=1, cat="Binary")

        # 2) Целевые коэффициенты (profit_score или revenue_score, округлено до 4 знаков!)-
        #Целевая функция описывает, чего мы стремимся достичь, например, максимизировать прибыль, минимизировать затраты или максимизировать выручку.
        # Итоговая цель будет: sum по ВСЕМ вариантам qty_var * коэффициент

        objective = []
        for c in filtered:
            s = c["sku_id"]
            p = c["percentile"]
            if optimization_goal == "profit":
                coef = round(c["profit_score"], 4)
            else:
                coef = round(c["revenue_score"], 4)
            objective.append( coef * qty_vars[(s, p)] )
        prob += pulp.lpSum(objective)

        # 3) Ограничения
        # --- (a) Бюджет ---
        budget_expr = []
        for c in filtered:
            s = c["sku_id"]
            p = c["percentile"]
            var = qty_vars[(s, p)]
            budget_expr.append(c["cost"] * var)
        prob += (pulp.lpSum(budget_expr) <= budget), "budget_constraint"

        # --- (b) Для каждого SKU ровно один percentile выбран ---
        # (только те варианты, которые прошли фильтр – т.е. с demand_to_buy > 0)
        import collections
        sku_to_pcts = collections.defaultdict(list)
        for c in filtered:
            sku_to_pcts[c["sku_id"]].append( c["percentile"] )

        for sku, pcts in sku_to_pcts.items():
            # Бинарные переменные по этому sku
            bin_sum = [bin_vars[(sku,p)] for p in pcts]
            prob += (pulp.lpSum(bin_sum) == 1), f"sku_{sku}_single_selection_constraint"

        # --- (c) Связь между qty_var и bin_var: если вариант не выбран, кол-во закупки = 0 ---
        for c in filtered:
            s = c["sku_id"]
            p = c["percentile"]
            demand_to_buy = c["demand_to_buy"]
            # qty_var <= demand_to_buy * bin_var
            # (все vars уже с границами)
            prob += (
                qty_vars[(s, p)] - demand_to_buy * bin_vars[(s, p)] <= 0
            ), f"sku_{s}_{p}_demand_constraint"

        # --- (d) (qty_var >= 0, bin_var in {0,1}) – уже через cat и upBound

        # --- Решаем задачу! ---
        prob.solve()

        # --- Формируем allocation_df из решения LP ---
        allocation_rows = []
        for c in filtered:
            s, p = c["sku_id"], c["percentile"]
            var_qty = qty_vars[(s,p)].varValue
            var_bin = bin_vars[(s,p)].varValue
            allocated_qty = int(round(var_qty)) if var_qty is not None else 0
            # В LP может быть такое, что qty == 0 и bin == 0
            if allocated_qty <= 0:
                continue  # не закупить совсем

            # Формируем строку (см. формат)
            row = {
                "sku_id": s,
                "percentile": int(p),
                "price": int(c["price"]),
                "cost": int(c["cost"]),
                "allocated_qty": allocated_qty,
                "allocated_budget": int(allocated_qty * c["cost"]),
                "expected_profit": int((c["price"] - c["cost"]) * allocated_qty),
                "expected_revenue": int(c["price"] * allocated_qty),
            }
            allocation_rows.append(row)
        #Фрейм данных, содержащий результаты распределения, включая идентификатор артикула,
        # выделенное количество, выделенный бюджет, ожидаемая прибыль и ожидаемый доход.
        allocation_df = pd.DataFrame(
            allocation_rows,
            columns=["sku_id","percentile","price","cost",
                     "allocated_qty","allocated_budget","expected_profit","expected_revenue"]
        )
        allocation_df = allocation_df.sort_values(
            by=["allocated_budget", "sku_id"], ascending=[False, True]
        )

        return prob, allocation_df

from tabulate import tabulate

products = [
    {
        "sku_id": "0001",
        "price": 317,
        "cost": 288,
        "current_stock": 22,
        "storage_time": 76,
        "percentiles": {
            "1w": {"5": 3, "10": 9, "25": 16, "50": 19, "75": 22, "90": 28, "95": 35},
            "2w": {"5": 9, "10": 10, "25": 22, "50": 28, "75": 31, "90": 37, "95": 43},
            "3w": {"5": 11, "10": 14, "25": 32, "50": 36, "75": 43, "90": 53, "95": 62},
            "4w": {"5": 12, "10": 24, "25": 33, "50": 46, "75": 53, "90": 60, "95": 71},
        },
    },
    {
        "sku_id": "0002",
        "price": 158,
        "cost": 143,
        "current_stock": 8,
        "storage_time": 65,
        "percentiles": {
            "1w": {"5": 6, "10": 7, "25": 9, "50": 19, "75": 23, "90": 25, "95": 32},
            "2w": {"5": 12, "10": 18, "25": 24, "50": 27, "75": 29, "90": 30, "95": 39},
            "3w": {"5": 17, "10": 24, "25": 34, "50": 37, "75": 47, "90": 54, "95": 62},
            "4w": {"5": 23, "10": 33, "25": 42, "50": 45, "75": 51, "90": 58, "95": 65},
        },
    },
]

lpr = LPRestock("products.json")

lpr.products = products

lp_prob, allocation_df = lpr.allocate(2000, 1, "profit")

print('Allocation df:')
print(tabulate(allocation_df, headers="keys", floatfmt="0.2f"))

total_cost = allocation_df["allocated_budget"].sum()
total_expected_profit = allocation_df["expected_profit"].sum()
print(f"\nОбщая сумма закупки: {total_cost}")
print(f"Общая ожидаемая прибыль: {total_expected_profit}")

print(f"\nЦелевая функция: {lp_prob.objective}")

print("\n Переменные решения:")
print(lp_prob.variables())

print("\nОграничения задачи линейного программирования:")
for name, constraint in lp_prob.constraints.items():
    print(f"{name}: {constraint}")

### Output:
# Allocation df:
#   sku_id    percentile    price    cost    allocated_qty    allocated_budget    expected_profit    expected_revenue
# --------  ------------  -------  ------  ---------------  ------------------  -----------------  ------------------
#     0002            50      158     143               11                1573                165                1738
#     0001            90      317     288                1                 288                 29                 317

# Общая сумма закупки: 1861
# Общая ожидаемая прибыль: 194

# Целевая функция: 0.0189*sku_0001_90 + 0.0095*sku_0001_95 + 0.1426*sku_0002_25 + 0.0951*sku_0002_50 + 0.0475*sku_0002_75 + 0.019*sku_0002_90 + 0.0095*sku_0002_95

#  Переменные решения: [
#     bin_sku_0001_90, bin_sku_0001_95, bin_sku_0002_25, bin_sku_0002_50, bin_sku_0002_75, bin_sku_0002_90, bin_sku_0002_95,
#     sku_0001_90, sku_0001_95, sku_0002_25, sku_0002_50, sku_0002_75, sku_0002_90, sku_0002_95
# ]

# Ограничения задачи линейного программирования:
# budget_constraint: 288*sku_0001_90 + 288*sku_0001_95 + 143*sku_0002_25 + 143*sku_0002_50 + 143*sku_0002_75 + 143*sku_0002_90 + 143*sku_0002_95 <= 2000
# sku_0001_single_selection_constraint: bin_sku_0001_90 + bin_sku_0001_95 = 1
# sku_0002_single_selection_constraint: bin_sku_0002_25 + bin_sku_0002_50 + bin_sku_0002_75 + bin_sku_0002_90 + bin_sku_0002_95 = 1
# sku_0001_90_demand_constraint: -6*bin_sku_0001_90 + sku_0001_90 <= 0
# sku_0001_95_demand_constraint: -13*bin_sku_0001_95 + sku_0001_95 <= 0
# sku_0002_25_demand_constraint: -bin_sku_0002_25 + sku_0002_25 <= 0
# sku_0002_50_demand_constraint: -11*bin_sku_0002_50 + sku_0002_50 <= 0
# sku_0002_75_demand_constraint: -15*bin_sku_0002_75 + sku_0002_75 <= 0
# sku_0002_90_demand_constraint: -17*bin_sku_0002_90 + sku_0002_90 <= 0
# sku_0002_95_demand_constraint: -24*bin_sku_0002_95 + sku_0002_95 <= 0

"""**Метрики анализа и оптимизации запасов**"""

class InventoryMetrics:
    def __init__(self, products):
        """
        Initializes the InventoryMetrics object with a list of products, each containing
        price, cost, starting and ending inventory values, and quantities sold.

        Args:
            products (list of dict): List of dictionaries, each representing a product.
            Each dictionary should contain:
                - 'name' (str): Name of the product.
                - 'price' (float): Selling price per unit.
                - 'cost' (float): Cost per unit.
                - 'quantity_sold' (int): Number of units sold.
                - 'inventory_start' (float): Value of inventory at the start of the period.
                - 'inventory_end' (float): Value of inventory at the end of the period.
        """
        self.products = products

    def gmv(self):
        """Calculates the total Gross Merchandise Value (GMV).

        Returns:
            float: The total GMV, which is the sum of the product of price and quantity sold for each product.
        """
        GMV = sum(p['price'] * p['quantity_sold'] for p in self.prosucts)
        return round(float(GMV), 2)

    def gross_margin(self):
        """Calculates the total Gross Margin.

        Returns:
            tuple: A tuple containing:
                - margin (float): The total Gross Margin, which is the difference between total revenue and total costs.
                - margin_percentage (float): The Gross Margin percentage, calculated as (margin / total revenue) * 100.
                  If total revenue is zero, returns 0 for the percentage.
        """
        total_revenue = sum(p['price'] * p['quantity_sold'] for p in self.products)
        total_cost = sum(p['cost'] * p['quantity_sold'] for p in self.products)
        margin = total_revenue - total_cost
        margin = round(margin, 2)

        if total_revenue > 0:
            margin_pct = round(margin / total_revenue * 100, 2)
        else:
            margin_pct = 0.0
        return margin, margin_pct

    def average_inventory_cost(self):
        """Calculates the total Average Inventory Cost.

        Returns:
            float: The total Average Inventory Cost, which is the sum of the average of starting
                   and ending inventory values for each product.
        """
        avg_inv_cost = sum((p['inventory_start'] + p['inventory_end']) / 2 for p in self.products)
        return round(avg_inv_cost, 2)

    def gmroi(self):
        """Calculates the total GMROI."""
        margin, _ = self.gross_margin()
        avg_inv_cost = self.average_inventory_cost()
        if avg_inv_cost == 0:
            return 0.0
        gmroi_val = margin / avg_inv_cost
        return round(gmroi_val, 2)


    def inventory_turnover(self):
        """Calculates the total Inventory Turnover."""
        total_cogs = sum(p['cost'] * p['quantity_sold'] for p in self.products)
        avg_inv_cost = self.average_inventory_cost()
        if avg_inv_cost == 0:
            return 0.0
        turnover = total_cogs / avg_inv_cost
        return round(turnover, 2)

    def turnover_period(self):
        """Calculates the total Turnover Period (in days)."""
        turnover = self.inventory_turnover()
        if turnover == 0:
            return 0.0
        period = 365 / turnover
        return round(period, 2)

#имитирует реальную бизнес-ситуацию, связанную с прогнозированием спроса, управлением запасами и логистикой для различных маркетплейсов
data = {
    #Содержит прогноз спроса на продукты по маркетплейсам
    "forecast_demand": [
        {
            "product": "sku_0001",
            "marketplace": "Ozz",
            "forecast_percentiles": {"10": 27, "25": 37, "50": 67, "75": 107, "90": 138},
        },
        {
            "product": "sku_0001",
            "marketplace": "WB",
            "forecast_percentiles": {"10": 22, "25": 36, "50": 89, "75": 90, "90": 126},
        },
        {
            "product": "sku_0001",
            "marketplace": "YM",
            "forecast_percentiles": {"10": 30, "25": 41, "50": 75, "75": 91, "90": 146},
        },
    ],
    #Данные о количестве товара в разных упаковках
    "bundle_sizes": [
        {"product": "sku_0001", "type": "small", "quantity": 17},
        {"product": "sku_0001", "type": "middle", "quantity": 34},
        {"product": "sku_0001", "type": "large", "quantity": 86},
    ],
    #Транспортные затраты для доставки комплектов товаров на маркетплейсы в формате словаря:
    "transport_costs": [
        {"sku_0001": {"Ozz": {"small": 1, "middle": 10, "large": 11}}},
        {"sku_0001": {"WB": {"small": 5, "middle": 10, "large": 15}}},
        {"sku_0001": {"YM": {"small": 4, "middle": 8, "large": 18}}},
    ],
    #Количество товара на центральном складе
    "warehouse_stocks": [{"product": "sku_0001", "quantity": 349}],
}

import json

class DataLoader:
    """
    A class to load and parse JSON data for managing forecast demand,
    warehouse stocks, bundle sizes, and transport costs for various products
    and marketplaces.
    """

    def __init__(self, json_file):
        """
        Initializes the DataLoader class with the specified JSON file path.

        Args:
            json_file (str): The path to the JSON file to be loaded.
        """
        self.json_file = json_file
        self.data = self.load_json()

        self.marketplaces = ["Ozz", "WB", "YM"]
        self.bundle_types = ["small", "middle", "large"]

        self.products = []
        self.forecast_demand = {}
        self.warehouse_stock = {}
        self.bundle_sizes = {}
        self.transport_costs = {}

        self.parse_data()

    def load_json(self):
        """
        Loads data from the specified JSON file.

        Returns:
            dict: The data loaded from the JSON file as a dictionary.
                  If the file is not found or there is an error in loading, returns None.
        Raises:
            FileNotFoundError: If the specified file is not found.
            JSONDecodeError: If there is an error in reading the JSON file.
        """
        try:
            with open(self.json_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            return data
        except FileNotFoundError:
            print(f"File not found: {self.json_file}")
            return None
        except json.JSONDecodeError:
            print(f"Error decoding JSON file: {self.json_file}")
            return None

    def parse_data(self):
        """
        Parses the loaded data from the JSON file and organizes it into
        forecast demand, warehouse stock, bundle sizes, and transport costs.
        Raises:
            KeyError: If any of the required keys ('forecast_demand', 'warehouse_stocks',
            'bundle_sizes', 'transport_costs') are missing in the JSON data.
        """
        if self.data is None:
            raise ValueError("No data loaded!")

        # 1. Forecast demand: {"sku": {"marketplace": {...}}}
        fd_table = {}
        for entry in self.data['forecast_demand']:
            sku = entry['product']
            mp = entry['marketplace']
            forecast = entry['forecast_percentiles']
            if sku not in fd_table:
                fd_table[sku] = {}
            fd_table[sku][mp] = forecast

        self.forecast_demand = fd_table

        # 2. Соберем список SKU (products)
        products_set = set()
        for entry in self.data['forecast_demand']:
            products_set.add(entry['product'])
        self.products = sorted(products_set)

        # 3. Склад: {"sku": quantity}
        wh_stock = {}
        for entry in self.data['warehouse_stocks']:
            sku = entry['product']
            quantity = entry['quantity']
            wh_stock[sku] = quantity
        self.warehouse_stock = wh_stock

        # 4. bundle_sizes: {"sku": {"small": q, "middle": q, "large": q}}
        bundles = {}
        for entry in self.data['bundle_sizes']:
            sku = entry['product']
            btype = entry['type']
            quantity = entry['quantity']
            if sku not in bundles:
                bundles[sku] = {}
            bundles[sku][btype] = quantity
        self.bundle_sizes = bundles

        # 5. transport_costs: {"sku": {"marketplace": {...}}}
        t_costs = {}
        for dct in self.data['transport_costs']:
            for sku, mp_info in dct.items():           # Обычно здесь только 1 sku в каждом dict
                if sku not in t_costs:
                    t_costs[sku] = {}
                for mp, bundles_info in mp_info.items():
                    t_costs[sku][mp] = bundles_info
        self.transport_costs = t_costs

loader = DataLoader("data.json")

print("Products: ", loader.products)
print("Forecast Demand:", loader.forecast_demand)
print("Warehouse Stock:", loader.warehouse_stock)
print("Bundles Data:", loader.bundle_sizes)
print("Transport Costs:", loader.transport_costs)

### Output:

# Products: ["sku_0001"]

# Forecast Demand:
# {
#     "sku_0001": {
#         "Ozz": {"10": 27, "25": 37, "50": 67, "75": 107, "90": 138},
#         "WB": {"10": 22, "25": 36, "50": 89, "75": 90, "90": 126},
#         "YM": {"10": 30, "25": 41, "50": 75, "75": 91, "90": 146},
#     }
# }

# Warehouse Stock: {"sku_0001": 349}

# Bundles Data: {"sku_0001": {"small": 17, "middle": 34, "large": 86}}

# Transport Costs: {
#     "sku_0001": {
#         "Ozz": {"small": 1, "middle": 10, "large": 11},
#         "WB": {"small": 5, "middle": 10, "large": 15},
#         "YM": {"small": 4, "middle": 8, "large": 18},
#     }
# }

import pulp

class DeliveryMaximization:
    """
    A class to model and solve a linear programming problem for maximizing
    deliveries of products to multiple marketplaces, given constraints on
    warehouse stock and forecasted demand.

    The goal is to maximize the number of delivered products while ensuring that
    deliveries are made within specified percentile ranges (minimum and maximum percentiles).
    """

    def __init__(
        self,
        products,
        marketplaces,
        forecast_demand,
        warehouse_stock,
        bundle_sizes,
        transport_costs,
        min_percentile,
        max_percentile,
    ):
        """
        Initializes the DeliveryMaximization class with necessary data.

        Args:
            products (list): A list of products to be delivered.
            marketplaces (list): A list of marketplaces where the products are delivered.
            forecast_demand (dict): Predicted demand for each product at each marketplace.
            warehouse_stock (dict): Available stock for each product in the warehouse.
            bundle_sizes (dict): Sizes of product bundles for each product.
            transport_costs (dict): Transport costs for each bundle type.
            min_percentile (int): The minimum percentile of demand that must be delivered to each marketplace.
            max_percentile (int): The maximum percentile of demand that can be delivered to each marketplace.

        Raises:
            ValueError: If the min_percentile or max_percentile is not in [10, 25, 50, 75, 90].
            ValueError: If min_percentile is greater than max_percentile.

        """
        self.products = products
        self.marketplaces = marketplaces
        self.forecast_demand = forecast_demand
        self.warehouse_stock = warehouse_stock
        self.bundle_sizes = bundle_sizes
        self.transport_costs = transport_costs

        self._valid_percentiles = [10, 25, 50, 75, 90]

        if min_percentile not in self._valid_percentiles:
            raise ValueError(f"min_percentile must be one of {self._valid_percentiles}")

        if max_percentile not in self._valid_percentiles:
            raise ValueError(f"max_percentile must be one of {self._valid_percentiles}")

        if min_percentile > max_percentile:
            raise ValueError("min_percentile cannot be greater than max_percentile")
        self.min_percentile = min_percentile
        self.max_percentile = max_percentile

        self.model = pulp.LpProblem("Maximize_Delivery", pulp.LpMaximize)
        self.decision_vars = {}

    def _define_decision_variables(self):
        """
        Defines the decision variables for each product, marketplace, and bundle size.

        The decision variables represent the number of bundles to deliver for
        each product to each marketplace.

        Переменные, принимающие решения, представляют собой количество пакетов для доставки каждого продукта на каждую торговую площадку.

        Variable Naming Format:
            x_{product}_{marketplace}_{bundle_size}
        """
        #
        for p in self.products:
            for m in self.marketplaces:
                for b in self.bundle_sizes[p].keys():
                    var_name = f"x_{p}_{m}_{b}"
                    # ОТЛИЧИЕ «cat»: Всё равно для теста допускает дробные значения, но ожидаем cat='Integer'
                    # Каждый вызов pulp.LpVariable() создает и возвращает объект переменной PuLP,
                    # который сохраняется в словаре - формирует название [('sku_0001', 'Ozz', 'small')]
                    self.decision_vars[(p, m, b)] = pulp.LpVariable(
                        var_name, lowBound=0, cat="Integer"
                    )

    def _define_objective(self):
        """
        Defines the objective function for the model.

        The objective is to maximize the total number of products delivered
        by considering bundle sizes for each product, marketplace, and bundle type.

        Цель состоит в том, чтобы максимально увеличить общее количество поставляемых продуктов
        учитывая размеры комплектов для каждого продукта, рынка сбыта и типа комплекта.

        Objective Function Format:
            Maximize: Σ (bundle_sizes[p][b] * x_{p}_{m}_{b})

        Наша задача — максимизировать эту сумму, то есть доставить наибольшее количество товаров в виде комплектов.

        размер комплекта (в единицах товара) для товара p и комплекта типа b
        """
        expr = []
        for p in self.products:
            for m in self.marketplaces:
              # количество единиц товара в упаковке типа b для товара p
              # переменная решения (сколько таких упаковок отправить)
              # Все слагаемые суммируются с помощью pulp.lpSum(expr)
                for b in self.bundle_sizes[p].keys():
                    expr.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
        # 10*x_sku1_Ozz_small + 50*x_sku1_Ozz_large +
        #  10*x_sku1_WB_small + 50*x_sku1_WB_large + ...
        self.model += pulp.lpSum(expr)

    def _add_constraints(self):
        """
        Adds the necessary constraints to the model.

            1. Ограничения на складские запасы: Общее количество доставленных посылок не может быть
               превысьте доступный запас по каждому продукту.
            2. Максимальная поставка: Общее количество поставляемых продуктов не может превышать
               прогнозируемый спрос на каждый продукт и рынок, основанный на максимальном процентиле.
            3. Минимальная поставка: общее количество поставляемых продуктов должно соответствовать минимуму
               прогнозируемый спрос для каждого продукта и рынка, основанный на минимальном процентиле.

            1. Warehouse stock limits: The total bundles delivered cannot
               exceed the available stock for each product.
            2. Maximum delivery: The total number of delivered products  cannot exceed the
               forecasted demand for each product and marketplace, based on the maximum percentile.
            3. Minimum delivery: The total number of delivered products  must meet the minimum
               forecasted demand for each product and marketplace, based on the minimum percentile.

        Constraint Naming Format:
            - Warehouse_Stock_{product}
            - MaxDelivery_{product}_{marketplace}
            - MinDelivery_{product}_{marketplace}
        """
        for p in self.products:
            # 1. Warehouse stock
            ws_constraint_name = f"Warehouse_Stock_{p}"
            total_expr = []
            for m in self.marketplaces:
                for b in self.bundle_sizes[p].keys():
                    total_expr.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
            self.model += (
                pulp.lpSum(total_expr) <= self.warehouse_stock[p],
                ws_constraint_name
            )

        for p in self.products:
            for m in self.marketplaces:
                # 2. Maximum delivery constraint
                max_constraint_name = f"MaxDelivery_{p}_{m}"
                delivered = []
                for b in self.bundle_sizes[p].keys():
                    delivered.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
                max_amount = self.forecast_demand[p][m][str(self.max_percentile)]
                self.model += (
                    pulp.lpSum(delivered) <= max_amount, max_constraint_name
                )
                # 3. Minimum delivery constraint
                min_constraint_name = f"MinDelivery_{p}_{m}"
                min_amount = self.forecast_demand[p][m][str(self.min_percentile)]
                self.model += (
                    pulp.lpSum(delivered) >= min_amount, min_constraint_name
                )

    def solve(self):
        """
        Solves the linear programming model.

        This method defines the decision variables, sets up the objective
        function, adds constraints, and solves the model using the solver.
        """
        self._define_decision_variables()
        self._define_objective()
        self._add_constraints()

        self.model.solve()

    def get_results(self):
        """
        Retrieves the results of the optimization, showing the total number of
        products delivered for each product and marketplace.

        Returns:
            dict: A dictionary where the key is a tuple of (str, str) representing
                  (product, marketplace) and the value is a float representing the total
                  number of products delivered to that marketplace.

            Format:
                {
                    (product: str, marketplace: str): total_delivered_quantity: float
                }
        """
        # Накапливаем по каждому (p, m) - количество единиц товара, через переменные всех b.
        results = {}
        for p in self.products:
            for m in self.marketplaces:
                total = 0.0
                for b in self.bundle_sizes[p].keys():
                    var = self.decision_vars[(p, m, b)]
                    val = var.varValue if var.varValue is not None else 0.0
                    total += self.bundle_sizes[p][b] * val
                    results[(p, m)] = float(total)
        return results

products = ["sku_0001", "sku_0002", "sku_0003"]

marketplaces = ["Ozz", "WB", "YM"]

forecast_demand = {
    "sku_0001": {
        "Ozz": {"10": 17, "25": 51, "50": 73, "75": 116, "90": 144},
        "WB": {"10": 26, "25": 53, "50": 64, "75": 102, "90": 150},
        "YM": {"10": 28, "25": 39, "50": 72, "75": 116, "90": 132},
    },
    "sku_0002": {
        "Ozz": {"10": 22, "25": 45, "50": 89, "75": 99, "90": 143},
        "WB": {"10": 27, "25": 58, "50": 89, "75": 115, "90": 131},
        "YM": {"10": 25, "25": 55, "50": 70, "75": 109, "90": 144},
    },
    "sku_0003": {
        "Ozz": {"10": 18, "25": 31, "50": 89, "75": 106, "90": 144},
        "WB": {"10": 17, "25": 36, "50": 88, "75": 93, "90": 146},
        "YM": {"10": 16, "25": 37, "50": 60, "75": 111, "90": 130},
    },
}

warehouse_stock = {"sku_0001": 642, "sku_0002": 128, "sku_0003": 365}

bundle_sizes = {
    "sku_0001": {"small": 5, "middle": 33, "large": 70},
    "sku_0002": {"small": 15, "middle": 41, "large": 89},
    "sku_0003": {"small": 9, "middle": 34, "large": 63},
}

transport_costs = {
    "sku_0001": {
        "Ozz": {"small": 4, "middle": 6, "large": 11},
        "WB": {"small": 2, "middle": 10, "large": 13},
        "YM": {"small": 7, "middle": 12, "large": 18},
    },
    "sku_0002": {
        "Ozz": {"small": 3, "middle": 6, "large": 15},
        "WB": {"small": 5, "middle": 11, "large": 17},
        "YM": {"small": 5, "middle": 11, "large": 13},
    },
    "sku_0003": {
        "Ozz": {"small": 4, "middle": 8, "large": 11},
        "WB": {"small": 4, "middle": 8, "large": 13},
        "YM": {"small": 5, "middle": 12, "large": 13},
    },
}

delivery_optimizer = DeliveryMaximization(
    products,
    marketplaces,
    forecast_demand,
    warehouse_stock,
    bundle_sizes,
    transport_costs,
    min_percentile=10,
    max_percentile=90,
)

delivery_optimizer.solve()
results = delivery_optimizer.get_results()

print("Результат оптимизации:")
print(results)

print(f"\nЦелевая функция: {delivery_optimizer.model.objective}")

print("\nПеременные решения:")
print(*delivery_optimizer.model.variables(), sep="\n")

print("\nОграничения задачи:")
for name, constraint in delivery_optimizer.model.constraints.items():
    print(f"{name}: {constraint}")

### Output:
### Результат оптимизации:
# {
#     ("sku_0001", "Ozz"): 144.0, ("sku_0001", "WB"): 150.0, ("sku_0001", "YM"): 132.0,
#     ("sku_0002", "Ozz"): 45.0, ("sku_0002", "WB"): 41.0, ("sku_0002", "YM"): 41.0,
#     ("sku_0003", "Ozz"): 95.0, ("sku_0003", "WB"): 144.0, ("sku_0003", "YM"): 126.0,
# }

### Целевая функция:
# 70*x_sku_0001_Ozz_large + 33*x_sku_0001_Ozz_middle + 5*x_sku_0001_Ozz_small + 70*x_sku_0001_WB_large + 33*x_sku_0001_WB_middle + 5*x_sku_0001_WB_small + 70*x_sku_0001_YM_large + 33*x_sku_0001_YM_middle + 5*x_sku_0001_YM_small +
# 89*x_sku_0002_Ozz_large + 41*x_sku_0002_Ozz_middle + 15*x_sku_0002_Ozz_small + 89*x_sku_0002_WB_large + 41*x_sku_0002_WB_middle + 15*x_sku_0002_WB_small + 89*x_sku_0002_YM_large + 41*x_sku_0002_YM_middle + 15*x_sku_0002_YM_small +
# 63*x_sku_0003_Ozz_large + 34*x_sku_0003_Ozz_middle + 9*x_sku_0003_Ozz_small + 63*x_sku_0003_WB_large + 34*x_sku_0003_WB_middle + 9*x_sku_0003_WB_small + 63*x_sku_0003_YM_large + 34*x_sku_0003_YM_middle + 9*x_sku_0003_YM_small

### Переменные решения:
# x_sku_0001_Ozz_large, x_sku_0001_Ozz_middle, x_sku_0001_Ozz_small
# x_sku_0001_WB_large, x_sku_0001_WB_middle, x_sku_0001_WB_small
# x_sku_0001_YM_large, x_sku_0001_YM_middle, x_sku_0001_YM_small
# x_sku_0002_Ozz_large, x_sku_0002_Ozz_middle, x_sku_0002_Ozz_small
# x_sku_0002_WB_large, x_sku_0002_WB_middle, x_sku_0002_WB_small
# x_sku_0002_YM_large, x_sku_0002_YM_middle, x_sku_0002_YM_small
# x_sku_0003_Ozz_large, x_sku_0003_Ozz_middle, x_sku_0003_Ozz_small
# x_sku_0003_WB_large, x_sku_0003_WB_middle, x_sku_0003_WB_small
# x_sku_0003_YM_large, x_sku_0003_YM_middle, x_sku_0003_YM_small

### Ограничения задачи:
# Warehouse_Stock_sku_0001: 70*x_sku_0001_Ozz_large + 33*x_sku_0001_Ozz_middle + 5*x_sku_0001_Ozz_small + 70*x_sku_0001_WB_large + 33*x_sku_0001_WB_middle + 5*x_sku_0001_WB_small + 70*x_sku_0001_YM_large + 33*x_sku_0001_YM_middle + 5*x_sku_0001_YM_small <= 642
# Warehouse_Stock_sku_0002: 89*x_sku_0002_Ozz_large + 41*x_sku_0002_Ozz_middle + 15*x_sku_0002_Ozz_small + 89*x_sku_0002_WB_large + 41*x_sku_0002_WB_middle + 15*x_sku_0002_WB_small + 89*x_sku_0002_YM_large + 41*x_sku_0002_YM_middle + 15*x_sku_0002_YM_small <= 128
# Warehouse_Stock_sku_0003: 63*x_sku_0003_Ozz_large + 34*x_sku_0003_Ozz_middle + 9*x_sku_0003_Ozz_small + 63*x_sku_0003_WB_large + 34*x_sku_0003_WB_middle + 9*x_sku_0003_WB_small + 63*x_sku_0003_YM_large + 34*x_sku_0003_YM_middle + 9*x_sku_0003_YM_small <= 365

# MaxDelivery_sku_0001_Ozz: 70*x_sku_0001_Ozz_large + 33*x_sku_0001_Ozz_middle + 5*x_sku_0001_Ozz_small <= 144
# MaxDelivery_sku_0001_WB: 70*x_sku_0001_WB_large + 33*x_sku_0001_WB_middle + 5*x_sku_0001_WB_small <= 150
# MaxDelivery_sku_0001_YM: 70*x_sku_0001_YM_large + 33*x_sku_0001_YM_middle + 5*x_sku_0001_YM_small <= 132
# MaxDelivery_sku_0002_Ozz: 89*x_sku_0002_Ozz_large + 41*x_sku_0002_Ozz_middle + 15*x_sku_0002_Ozz_small <= 143
# MaxDelivery_sku_0002_WB: 89*x_sku_0002_WB_large + 41*x_sku_0002_WB_middle + 15*x_sku_0002_WB_small <= 131
# MaxDelivery_sku_0002_YM: 89*x_sku_0002_YM_large + 41*x_sku_0002_YM_middle + 15*x_sku_0002_YM_small <= 144
# MaxDelivery_sku_0003_Ozz: 63*x_sku_0003_Ozz_large + 34*x_sku_0003_Ozz_middle + 9*x_sku_0003_Ozz_small <= 144
# MaxDelivery_sku_0003_WB: 63*x_sku_0003_WB_large + 34*x_sku_0003_WB_middle + 9*x_sku_0003_WB_small <= 146
# MaxDelivery_sku_0003_YM: 63*x_sku_0003_YM_large + 34*x_sku_0003_YM_middle + 9*x_sku_0003_YM_small <= 130

# MinDelivery_sku_0001_Ozz: 70*x_sku_0001_Ozz_large + 33*x_sku_0001_Ozz_middle + 5*x_sku_0001_Ozz_small >= 17
# MinDelivery_sku_0001_WB: 70*x_sku_0001_WB_large + 33*x_sku_0001_WB_middle + 5*x_sku_0001_WB_small >= 26
# MinDelivery_sku_0001_YM: 70*x_sku_0001_YM_large + 33*x_sku_0001_YM_middle + 5*x_sku_0001_YM_small >= 28
# MinDelivery_sku_0002_Ozz: 89*x_sku_0002_Ozz_large + 41*x_sku_0002_Ozz_middle + 15*x_sku_0002_Ozz_small >= 22
# MinDelivery_sku_0002_WB: 89*x_sku_0002_WB_large + 41*x_sku_0002_WB_middle + 15*x_sku_0002_WB_small >= 27
# MinDelivery_sku_0002_YM: 89*x_sku_0002_YM_large + 41*x_sku_0002_YM_middle + 15*x_sku_0002_YM_small >= 25
# MinDelivery_sku_0003_Ozz: 63*x_sku_0003_Ozz_large + 34*x_sku_0003_Ozz_middle + 9*x_sku_0003_Ozz_small >= 18
# MinDelivery_sku_0003_WB: 63*x_sku_0003_WB_large + 34*x_sku_0003_WB_middle + 9*x_sku_0003_WB_small >= 17
# MinDelivery_sku_0003_YM: 63*x_sku_0003_YM_large + 34*x_sku_0003_YM_middle + 9*x_sku_0003_YM_small >= 16

import pulp
import json

class DataLoader:
    """
    A class to load and parse JSON data for managing forecast demand,
    warehouse stocks, bundle sizes, and transport costs for various products
    and marketplaces.
    """

    def __init__(self, json_file):
        """
        Initializes the DataLoader class with the specified JSON file path.

        Args:
            json_file (str): The path to the JSON file to be loaded.
        """
        self.json_file = json_file
        self.data = self.load_json()

        self.marketplaces = ["Ozz", "WB", "YM"]
        self.bundle_types = ["small", "middle", "large"]

        self.products = []
        self.forecast_demand = {}
        self.warehouse_stock = {}
        self.bundle_sizes = {}
        self.transport_costs = {}

        self.parse_data()

    def load_json(self):
        """
        Loads data from the specified JSON file.

        Returns:
            dict: The data loaded from the JSON file as a dictionary.
                  If the file is not found or there is an error in loading, returns None.
        Raises:
            FileNotFoundError: If the specified file is not found.
            JSONDecodeError: If there is an error in reading the JSON file.
        """
        try:
            with open(self.json_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            return data
        except FileNotFoundError:
            print(f"File not found: {self.json_file}")
            return None
        except json.JSONDecodeError:
            print(f"Error decoding JSON file: {self.json_file}")
            return None

    def parse_data(self):
        """
        Parses the loaded data from the JSON file and organizes it into
        forecast demand, warehouse stock, bundle sizes, and transport costs.
        Raises:
            KeyError: If any of the required keys ('forecast_demand', 'warehouse_stocks',
            'bundle_sizes', 'transport_costs') are missing in the JSON data.
        """
        if self.data is None:
            raise ValueError("No data loaded!")

        # 1. Forecast demand: {"sku": {"marketplace": {...}}}
        fd_table = {}
        for entry in self.data['forecast_demand']:
            sku = entry['product']
            mp = entry['marketplace']
            forecast = entry['forecast_percentiles']
            if sku not in fd_table:
                fd_table[sku] = {}
            fd_table[sku][mp] = forecast

        self.forecast_demand = fd_table

        # 2. Соберем список SKU (products)
        products_set = set()
        for entry in self.data['forecast_demand']:
            products_set.add(entry['product'])
        self.products = sorted(products_set)

        # 3. Склад: {"sku": quantity}
        wh_stock = {}
        for entry in self.data['warehouse_stocks']:
            sku = entry['product']
            quantity = entry['quantity']
            wh_stock[sku] = quantity
        self.warehouse_stock = wh_stock

        # 4. bundle_sizes: {"sku": {"small": q, "middle": q, "large": q}}
        bundles = {}
        for entry in self.data['bundle_sizes']:
            sku = entry['product']
            btype = entry['type']
            quantity = entry['quantity']
            if sku not in bundles:
                bundles[sku] = {}
            bundles[sku][btype] = quantity
        self.bundle_sizes = bundles

        # 5. transport_costs: {"sku": {"marketplace": {...}}}
        t_costs = {}
        for dct in self.data['transport_costs']:
            for sku, mp_info in dct.items():           # Обычно здесь только 1 sku в каждом dict
                if sku not in t_costs:
                    t_costs[sku] = {}
                for mp, bundles_info in mp_info.items():
                    t_costs[sku][mp] = bundles_info
        self.transport_costs = t_costs

class DeliveryMaximization:
    """
    A class to model and solve a linear programming problem for maximizing
    deliveries of products to multiple marketplaces, given constraints on
    warehouse stock and forecasted demand.

    The goal is to maximize the number of delivered products while ensuring that
    deliveries are made within specified percentile ranges (minimum and maximum percentiles).
    """

    def __init__(
        self,
        products,
        marketplaces,
        forecast_demand,
        warehouse_stock,
        bundle_sizes,
        transport_costs,
        min_percentile,
        max_percentile,
    ):
        """
        Initializes the DeliveryMaximization class with necessary data.

        Args:
            products (list): A list of products to be delivered.
            marketplaces (list): A list of marketplaces where the products are delivered.
            forecast_demand (dict): Predicted demand for each product at each marketplace.
            warehouse_stock (dict): Available stock for each product in the warehouse.
            bundle_sizes (dict): Sizes of product bundles for each product.
            transport_costs (dict): Transport costs for each bundle type.
            min_percentile (int): The minimum percentile of demand that must be delivered to each marketplace.
            max_percentile (int): The maximum percentile of demand that can be delivered to each marketplace.

        Raises:
            ValueError: If the min_percentile or max_percentile is not in [10, 25, 50, 75, 90].
            ValueError: If min_percentile is greater than max_percentile.

        """
        self.products = products
        self.marketplaces = marketplaces
        self.forecast_demand = forecast_demand
        self.warehouse_stock = warehouse_stock
        self.bundle_sizes = bundle_sizes
        self.transport_costs = transport_costs

        self._valid_percentiles = [10, 25, 50, 75, 90]

        if min_percentile not in self._valid_percentiles:
            raise ValueError(f"min_percentile must be one of {self._valid_percentiles}")

        if max_percentile not in self._valid_percentiles:
            raise ValueError(f"max_percentile must be one of {self._valid_percentiles}")

        if min_percentile > max_percentile:
            raise ValueError("min_percentile cannot be greater than max_percentile")
        self.min_percentile = min_percentile
        self.max_percentile = max_percentile

        self.model = pulp.LpProblem("Maximize_Delivery", pulp.LpMaximize)
        self.decision_vars = {}

    def _define_decision_variables(self):
        """
        Defines the decision variables for each product, marketplace, and bundle size.

        The decision variables represent the number of bundles to deliver for
        each product to each marketplace.

        Переменные, принимающие решения, представляют собой количество пакетов для доставки каждого продукта на каждую торговую площадку.

        Variable Naming Format:
            x_{product}_{marketplace}_{bundle_size}
        """
        #
        for p in self.products:
            for m in self.marketplaces:
                for b in self.bundle_sizes[p].keys():
                    var_name = f"x_{p}_{m}_{b}"
                    # ОТЛИЧИЕ «cat»: Всё равно для теста допускает дробные значения, но ожидаем cat='Integer'
                    # Каждый вызов pulp.LpVariable() создает и возвращает объект переменной PuLP,
                    # который сохраняется в словаре - формирует название [('sku_0001', 'Ozz', 'small')]
                    self.decision_vars[(p, m, b)] = pulp.LpVariable(
                        var_name, lowBound=0, cat="Integer"
                    )

    def _define_objective(self):
        """
        Defines the objective function for the model.

        The objective is to maximize the total number of products delivered
        by considering bundle sizes for each product, marketplace, and bundle type.

        Цель состоит в том, чтобы максимально увеличить общее количество поставляемых продуктов
        учитывая размеры комплектов для каждого продукта, рынка сбыта и типа комплекта.

        Objective Function Format:
            Maximize: Σ (bundle_sizes[p][b] * x_{p}_{m}_{b})

        Наша задача — максимизировать эту сумму, то есть доставить наибольшее количество товаров в виде комплектов.

        размер комплекта (в единицах товара) для товара p и комплекта типа b
        """
        expr = []
        for p in self.products:
            for m in self.marketplaces:
              # количество единиц товара в упаковке типа b для товара p
              # переменная решения (сколько таких упаковок отправить)
              # Все слагаемые суммируются с помощью pulp.lpSum(expr)
                for b in self.bundle_sizes[p].keys():
                    expr.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
        # 10*x_sku1_Ozz_small + 50*x_sku1_Ozz_large +
        #  10*x_sku1_WB_small + 50*x_sku1_WB_large + ...
        self.model += pulp.lpSum(expr)

    def _add_constraints(self):
        """
        Adds the necessary constraints to the model.

            1. Ограничения на складские запасы: Общее количество доставленных посылок не может быть
               превысьте доступный запас по каждому продукту.
            2. Максимальная поставка: Общее количество поставляемых продуктов не может превышать
               прогнозируемый спрос на каждый продукт и рынок, основанный на максимальном процентиле.
            3. Минимальная поставка: общее количество поставляемых продуктов должно соответствовать минимуму
               прогнозируемый спрос для каждого продукта и рынка, основанный на минимальном процентиле.

            1. Warehouse stock limits: The total bundles delivered cannot
               exceed the available stock for each product.
            2. Maximum delivery: The total number of delivered products  cannot exceed the
               forecasted demand for each product and marketplace, based on the maximum percentile.
            3. Minimum delivery: The total number of delivered products  must meet the minimum
               forecasted demand for each product and marketplace, based on the minimum percentile.

        Constraint Naming Format:
            - Warehouse_Stock_{product}
            - MaxDelivery_{product}_{marketplace}
            - MinDelivery_{product}_{marketplace}
        """
        for p in self.products:
            # 1. Warehouse stock
            ws_constraint_name = f"Warehouse_Stock_{p}"
            total_expr = []
            for m in self.marketplaces:
                for b in self.bundle_sizes[p].keys():
                    total_expr.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
            self.model += (
                pulp.lpSum(total_expr) <= self.warehouse_stock[p],
                ws_constraint_name
            )

        for p in self.products:
            for m in self.marketplaces:
                # 2. Maximum delivery constraint
                max_constraint_name = f"MaxDelivery_{p}_{m}"
                delivered = []
                for b in self.bundle_sizes[p].keys():
                    delivered.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
                max_amount = self.forecast_demand[p][m][str(self.max_percentile)]
                self.model += (
                    pulp.lpSum(delivered) <= max_amount, max_constraint_name
                )
                # 3. Minimum delivery constraint
                min_constraint_name = f"MinDelivery_{p}_{m}"
                min_amount = self.forecast_demand[p][m][str(self.min_percentile)]
                self.model += (
                    pulp.lpSum(delivered) >= min_amount, min_constraint_name
                )

    def solve(self):
        """
        Solves the linear programming model.

        This method defines the decision variables, sets up the objective
        function, adds constraints, and solves the model using the solver.
        """
        self._define_decision_variables()
        self._define_objective()
        self._add_constraints()

        self.model.solve()

    def get_results(self):
        """
        Retrieves the results of the optimization, showing the total number of
        products delivered for each product and marketplace.

        Returns:
            dict: A dictionary where the key is a tuple of (str, str) representing
                  (product, marketplace) and the value is a float representing the total
                  number of products delivered to that marketplace.

            Format:
                {
                    (product: str, marketplace: str): total_delivered_quantity: float
                }
        """
        # Накапливаем по каждому (p, m) - количество единиц товара, через переменные всех b.
        results = {}
        for p in self.products:
            for m in self.marketplaces:
                total = 0.0
                for b in self.bundle_sizes[p].keys():
                    var = self.decision_vars[(p, m, b)]
                    val = var.varValue if var.varValue is not None else 0.0
                    total += self.bundle_sizes[p][b] * val
                    results[(p, m)] = float(total)
        return results

class CostMinimization:
    """
    A class to model and solve the problem of minimizing transport costs
    for delivering products to different marketplaces.
    """

    def __init__(
        self,
        products,
        marketplaces,
        forecast_demand,
        warehouse_stock,
        bundle_sizes,
        transport_costs,
        max_delivered_per_sku_mp,
    ):
        self.products = products
        self.marketplaces = marketplaces
        self.forecast_demand = forecast_demand
        self.warehouse_stock = warehouse_stock
        self.bundle_sizes = bundle_sizes
        self.transport_costs = transport_costs
        self.max_delivered_per_sku_mp = max_delivered_per_sku_mp # dict: (p,m) -> quantity
        self.model = pulp.LpProblem("Minimize_Cost", pulp.LpMinimize)
        self.decision_vars = {}

    def _define_decision_variables(self):
        """
        Defines the decision variables for each product, marketplace, and bundle size.
        Variable Naming Format: x_{product}_{marketplace}_{bundle_size}
        """
        for p in self.products:
            for m in self.marketplaces:
                for b in self.bundle_sizes[p]:
                    var_name = f"x_{p}_{m}_{b}"
                    self.decision_vars[(p, m, b)] = pulp.LpVariable(
                        var_name, lowBound=0, cat="Integer"
                    )

    def _define_objective(self):
        """
        Minimize: Σ (transport_costs[p][m][b] * x_{p}_{m}_{b})
        """
        expr = []
        for p in self.products:
            for m in self.marketplaces:
                for b in self.bundle_sizes[p]:
                    cost = self.transport_costs[p][m][b]
                    var = self.decision_vars[(p, m, b)]
                    expr.append(cost * var)
        self.model += pulp.lpSum(expr)

    def _add_constraints(self):
        """
        Adds:
        1. Max delivery constraint (per product & marketplace).
        2. Warehouse stock constraint (per product).
        """
        # 1. Максимизация доставки - для каждого товара и маркетплейса:
        #    sum_b (x_{p,m,b} * bundle_size[p][b]) == max_delivered_per_sku_mp[(p,m)]
        for p in self.products:
            for m in self.marketplaces:
                expr = []
                for b in self.bundle_sizes[p]:
                    expr.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
                constraint_name = f"MaxDelivery_{p}_{m}"
                rhs = self.max_delivered_per_sku_mp.get((p, m), 0)
                self.model += (pulp.lpSum(expr) == rhs, constraint_name)

        # 2. Склад - для каждого товара общее <= warehouse_stock[p]
        for p in self.products:
            expr = []
            for m in self.marketplaces:
                for b in self.bundle_sizes[p]:
                    expr.append(self.bundle_sizes[p][b] * self.decision_vars[(p, m, b)])
            constraint_name = f"Warehouse_Stock_{p}"
            self.model += (pulp.lpSum(expr) <= self.warehouse_stock[p], constraint_name)

    def solve(self):
        """
        Solves the optimization problem.
        """
        self._define_decision_variables()
        self._define_objective()
        self._add_constraints()
        self.model.solve()

    def get_results(self):
        """
        Returns:
            tuple: (total_cost, bundles)
                total_cost (float)
                bundles (list of dict)
        """
        # Total minimized cost
        total_cost = pulp.value(self.model.objective)
        # Bundles to deliver per (product, marketplace, bundle_type)
        bundles = []
        for (p, m, b), var in self.decision_vars.items():
            value = int(round(var.varValue)) if var.varValue is not None else 0
            # Возвращаем только не-ноль
            if value >= 0:
                bundles.append({
                    "product": p,
                    "marketplace": m,
                    "bundle_type": b,
                    "bundles": value
                })
        return total_cost, bundles

products = ["sku_0001", "sku_0002", "sku_0003"]

marketplaces = ["Ozz", "WB", "YM"]

forecast_demand = {
    "sku_0001": {
        "Ozz": {"10": 17, "25": 51, "50": 73, "75": 116, "90": 144},
        "WB": {"10": 26, "25": 53, "50": 64, "75": 102, "90": 150},
        "YM": {"10": 28, "25": 39, "50": 72, "75": 116, "90": 132},
    },
    "sku_0002": {
        "Ozz": {"10": 22, "25": 45, "50": 89, "75": 99, "90": 143},
        "WB": {"10": 27, "25": 58, "50": 89, "75": 115, "90": 131},
        "YM": {"10": 25, "25": 55, "50": 70, "75": 109, "90": 144},
    },
    "sku_0003": {
        "Ozz": {"10": 18, "25": 31, "50": 89, "75": 106, "90": 144},
        "WB": {"10": 17, "25": 36, "50": 88, "75": 93, "90": 146},
        "YM": {"10": 16, "25": 37, "50": 60, "75": 111, "90": 130},
    },
}

warehouse_stock = {"sku_0001": 642, "sku_0002": 128, "sku_0003": 365}

bundle_sizes = {
    "sku_0001": {"small": 5, "middle": 33, "large": 70},
    "sku_0002": {"small": 15, "middle": 41, "large": 89},
    "sku_0003": {"small": 9, "middle": 34, "large": 63},
}

transport_costs = {
    "sku_0001": {
        "Ozz": {"small": 4, "middle": 6, "large": 11},
        "WB": {"small": 2, "middle": 10, "large": 13},
        "YM": {"small": 7, "middle": 12, "large": 18},
    },
    "sku_0002": {
        "Ozz": {"small": 3, "middle": 6, "large": 15},
        "WB": {"small": 5, "middle": 11, "large": 17},
        "YM": {"small": 5, "middle": 11, "large": 13},
    },
    "sku_0003": {
        "Ozz": {"small": 4, "middle": 8, "large": 11},
        "WB": {"small": 4, "middle": 8, "large": 13},
        "YM": {"small": 5, "middle": 12, "large": 13},
    },
}

# Step 1: Create an instance of DeliveryMaximization
# to solve for the maximum number of products delivered
delivery_optimizer = DeliveryMaximization(
    products,
    marketplaces,
    forecast_demand,
    warehouse_stock,
    bundle_sizes,
    transport_costs,
    min_percentile=10,
    max_percentile=90,
)

delivery_optimizer.solve()
max_delivered_per_sku_mp = delivery_optimizer.get_results()

# Step 2: Create an instance of CostMinimization
# to minimize the delivery costs given the maximum number of delivered products
cost_optimizer = CostMinimization(
    products,
    marketplaces,
    forecast_demand,
    warehouse_stock,
    bundle_sizes,
    transport_costs,
    max_delivered_per_sku_mp,  # Results from the first step of delivery maximization
)

cost_optimizer.solve()
total_cost, bundles = cost_optimizer.get_results()

print(f"Общая стоимость доставки: {total_cost}")

print("Сформированные комплекты:")
print(*bundles, sep="\n")

print(f"\nЦелевая функция: {cost_optimizer.model.objective}")

print("\nПеременные решения:")
print(*cost_optimizer.model.variables(), sep="\n")

print("\nОграничения задачи:")
for name, constraint in cost_optimizer.model.constraints.items():
    print(f"{name}: {constraint}")

### Output:
# Общая стоимость доставки: 251.0

###Сформированные комплекты:
# {'product': 'sku_0001', 'marketplace': 'Ozz', 'bundle_type': 'small', 'bundles': 9}
# {'product': 'sku_0001', 'marketplace': 'Ozz', 'bundle_type': 'middle', 'bundles': 3}
# {'product': 'sku_0001', 'marketplace': 'Ozz', 'bundle_type': 'large', 'bundles': 0}
# {'product': 'sku_0001', 'marketplace': 'WB', 'bundle_type': 'small', 'bundles': 2}
# {'product': 'sku_0001', 'marketplace': 'WB', 'bundle_type': 'middle', 'bundles': 0}
# {'product': 'sku_0001', 'marketplace': 'WB', 'bundle_type': 'large', 'bundles': 2}
# {'product': 'sku_0001', 'marketplace': 'YM', 'bundle_type': 'small', 'bundles': 0}
# {'product': 'sku_0001', 'marketplace': 'YM', 'bundle_type': 'middle', 'bundles': 4}
# {'product': 'sku_0001', 'marketplace': 'YM', 'bundle_type': 'large', 'bundles': 0}
# {'product': 'sku_0002', 'marketplace': 'Ozz', 'bundle_type': 'small', 'bundles': 3}
# {'product': 'sku_0002', 'marketplace': 'Ozz', 'bundle_type': 'middle', 'bundles': 0}
# {'product': 'sku_0002', 'marketplace': 'Ozz', 'bundle_type': 'large', 'bundles': 0}
# {'product': 'sku_0002', 'marketplace': 'WB', 'bundle_type': 'small', 'bundles': 0}
# {'product': 'sku_0002', 'marketplace': 'WB', 'bundle_type': 'middle', 'bundles': 1}
# {'product': 'sku_0002', 'marketplace': 'WB', 'bundle_type': 'large', 'bundles': 0}
# {'product': 'sku_0002', 'marketplace': 'YM', 'bundle_type': 'small', 'bundles': 0}
# {'product': 'sku_0002', 'marketplace': 'YM', 'bundle_type': 'middle', 'bundles': 1}
# {'product': 'sku_0002', 'marketplace': 'YM', 'bundle_type': 'large', 'bundles': 0}
# {'product': 'sku_0003', 'marketplace': 'Ozz', 'bundle_type': 'small', 'bundles': 3}
# {'product': 'sku_0003', 'marketplace': 'Ozz', 'bundle_type': 'middle', 'bundles': 2}
# {'product': 'sku_0003', 'marketplace': 'Ozz', 'bundle_type': 'large', 'bundles': 0}
# {'product': 'sku_0003', 'marketplace': 'WB', 'bundle_type': 'small', 'bundles': 2}
# {'product': 'sku_0003', 'marketplace': 'WB', 'bundle_type': 'middle', 'bundles': 0}
# {'product': 'sku_0003', 'marketplace': 'WB', 'bundle_type': 'large', 'bundles': 2}
# {'product': 'sku_0003', 'marketplace': 'YM', 'bundle_type': 'small', 'bundles': 0}
# {'product': 'sku_0003', 'marketplace': 'YM', 'bundle_type': 'middle', 'bundles': 0}
# {'product': 'sku_0003', 'marketplace': 'YM', 'bundle_type': 'large', 'bundles': 2}

### Целевая функция:
# 11*x_sku_0001_Ozz_large + 6*x_sku_0001_Ozz_middle + 4*x_sku_0001_Ozz_small + 13*x_sku_0001_WB_large + 10*x_sku_0001_WB_middle + 2*x_sku_0001_WB_small + 18*x_sku_0001_YM_large + 12*x_sku_0001_YM_middle + 7*x_sku_0001_YM_small +
# 15*x_sku_0002_Ozz_large + 6*x_sku_0002_Ozz_middle + 3*x_sku_0002_Ozz_small + 17*x_sku_0002_WB_large + 11*x_sku_0002_WB_middle + 5*x_sku_0002_WB_small + 13*x_sku_0002_YM_large + 11*x_sku_0002_YM_middle + 5*x_sku_0002_YM_small +
# 11*x_sku_0003_Ozz_large + 8*x_sku_0003_Ozz_middle + 4*x_sku_0003_Ozz_small + 13*x_sku_0003_WB_large + 8*x_sku_0003_WB_middle + 4*x_sku_0003_WB_small + 13*x_sku_0003_YM_large + 12*x_sku_0003_YM_middle + 5*x_sku_0003_YM_small

### Переменные решения:
# x_sku_0001_Ozz_large, x_sku_0001_Ozz_middle, x_sku_0001_Ozz_small
# x_sku_0001_WB_large, x_sku_0001_WB_middle, x_sku_0001_WB_small
# x_sku_0001_YM_large, x_sku_0001_YM_middle, x_sku_0001_YM_small
# x_sku_0002_Ozz_large, x_sku_0002_Ozz_middle, x_sku_0002_Ozz_small
# x_sku_0002_WB_large, x_sku_0002_WB_middle, x_sku_0002_WB_small
# x_sku_0002_YM_large, x_sku_0002_YM_middle, x_sku_0002_YM_small
# x_sku_0003_Ozz_large, x_sku_0003_Ozz_middle, x_sku_0003_Ozz_small
# x_sku_0003_WB_large, x_sku_0003_WB_middle, x_sku_0003_WB_small
# x_sku_0003_YM_large, x_sku_0003_YM_middle, x_sku_0003_YM_small

### Ограничения задачи:
# MaxDelivery_sku_0001_Ozz: 70*x_sku_0001_Ozz_large + 33*x_sku_0001_Ozz_middle + 5*x_sku_0001_Ozz_small = 144.0
# MaxDelivery_sku_0001_WB: 70*x_sku_0001_WB_large + 33*x_sku_0001_WB_middle + 5*x_sku_0001_WB_small = 150.0
# MaxDelivery_sku_0001_YM: 70*x_sku_0001_YM_large + 33*x_sku_0001_YM_middle + 5*x_sku_0001_YM_small = 132.0
# MaxDelivery_sku_0002_Ozz: 89*x_sku_0002_Ozz_large + 41*x_sku_0002_Ozz_middle + 15*x_sku_0002_Ozz_small = 45.0
# MaxDelivery_sku_0002_WB: 89*x_sku_0002_WB_large + 41*x_sku_0002_WB_middle + 15*x_sku_0002_WB_small = 41.0
# MaxDelivery_sku_0002_YM: 89*x_sku_0002_YM_large + 41*x_sku_0002_YM_middle + 15*x_sku_0002_YM_small = 41.0
# MaxDelivery_sku_0003_Ozz: 63*x_sku_0003_Ozz_large + 34*x_sku_0003_Ozz_middle + 9*x_sku_0003_Ozz_small = 95.0
# MaxDelivery_sku_0003_WB: 63*x_sku_0003_WB_large + 34*x_sku_0003_WB_middle + 9*x_sku_0003_WB_small = 144.0
# MaxDelivery_sku_0003_YM: 63*x_sku_0003_YM_large + 34*x_sku_0003_YM_middle + 9*x_sku_0003_YM_small = 126.0

# Warehouse_Stock_sku_0001: 70*x_sku_0001_Ozz_large + 33*x_sku_0001_Ozz_middle + 5*x_sku_0001_Ozz_small + 70*x_sku_0001_WB_large + 33*x_sku_0001_WB_middle + 5*x_sku_0001_WB_small + 70*x_sku_0001_YM_large + 33*x_sku_0001_YM_middle + 5*x_sku_0001_YM_small <= 642
# Warehouse_Stock_sku_0002: 89*x_sku_0002_Ozz_large + 41*x_sku_0002_Ozz_middle + 15*x_sku_0002_Ozz_small + 89*x_sku_0002_WB_large + 41*x_sku_0002_WB_middle + 15*x_sku_0002_WB_small + 89*x_sku_0002_YM_large + 41*x_sku_0002_YM_middle + 15*x_sku_0002_YM_small <= 128
# Warehouse_Stock_sku_0003: 63*x_sku_0003_Ozz_large + 34*x_sku_0003_Ozz_middle + 9*x_sku_0003_Ozz_small + 63*x_sku_0003_WB_large + 34*x_sku_0003_WB_middle + 9*x_sku_0003_WB_small + 63*x_sku_0003_YM_large + 34*x_sku_0003_YM_middle + 9*x_sku_0003_YM_small <= 365