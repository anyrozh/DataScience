# -*- coding: utf-8 -*-
"""GMROI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qN0gaD6PyA86hkJ1L-M66v88kxc5f0Qf

Слишком большой объём запасов приводит к замораживанию средств и увеличению расходов на хранение, тогда как недостаток товаров может оттолкнуть покупателей и привести к потере прибыли. **GMROI помогает найти баланс, чтобы минимизировать издержки и увеличить доходность.**



1) GMROI > 1: Хорошие показатели рентабельности запасов; чем выше, тем лучше.

2) GMROI < 1: Показатель ниже 1 свидетельствует о низкой эффективности — компания либо имеет избыточные запасы, либо продает недостаточно товаров.
"""

from typing import List
import pandas as pd


class GMROI:
    """
    Initializes the GMROI instance by loading product, sales, stock, and purchase data
    from specified CSV files, and calculating GMROI metrics based on seller and category.
    """

    def __init__(
        self,
        products_path: str,
        sales_path: str,
        stocks_path: str,
        purchases_path: str,
    ):
        """
        Initializes GMROI instance by loading data from CSV files and processing the data.
        """
        self._products_df = self._load_csv(products_path)
        self._sales_df = self._load_csv(sales_path)
        self._stocks_df = self._load_csv(stocks_path)
        self._purchases_df = self._load_csv(purchases_path)

        self.seller_gmroi = self._process_gmroi(["week", "seller_id"])
        self.category_gmroi = self._process_gmroi(["week", "category_id"])
        self.purchases = self._process_purchases()

    def _load_csv(self, file_path: str) -> pd.DataFrame:
        """
        Loads a CSV file into a DataFrame.

        Parameters:
            file_path (str): Path to the CSV file.

        Returns:
            pd.DataFrame: Loaded data.

        Raises:
            FileNotFoundError: If the file is not found.
            RuntimeError: For any other exceptions during file loading.
        """
        try:
            return pd.read_csv(file_path)
        except FileNotFoundError:
            raise FileNotFoundError(f"File not found: {file_path}")
        except Exception as e:
            raise RuntimeError(f"Error loading file {file_path}: {e}")

    def _process_gmroi(self, group_columns: List[str]) -> pd.DataFrame:
        """
        Processes data to calculate GMROI (Gross Margin Return on Investment)
        by aggregating margin, logistic costs, and inventory costs across specified
        grouping columns.

        Parameters:
            group_columns (List[str]): List of columns to group the data by,
                such as ["week"] for weekly GMROI, or ["week", "seller_id"] for
                GMROI per seller.

        Returns:
            pd.DataFrame: DataFrame with calculated GMROI for each group, containing:
                - week (str): Week of the data.
                - group columns (varies): Columns used for grouping (e.g., seller_id, category_id).
                - gmroi (float): Calculated GMROI value.

        Raises:
            ValueError: If `group_columns` does not match allowed groupings.

        Sorting:
            Resulting DataFrame is sorted by `week` and any additional group columns.
        """
        valid_group_columns = [
            ["week"],
            ["week", "seller_id"],
            ["week", "category_id"],
        ]
        if group_columns not in valid_group_columns:
            raise ValueError("Invalid group_columns")

        # Merge products with sales
        sales_products = pd.merge(
            self._sales_df, self._products_df, on=["week", "seller_id", "product_id"]
        )
        # Calculate revenue and cost of goods sold
        sales_products["revenue"] = sales_products["qty"] * sales_products["price"]
        sales_products["cogs"] = sales_products["qty"] * sales_products["cost"]
        sales_products["margin"] = sales_products["revenue"] - sales_products["cogs"]

        # Merge with stocks to get storage costs and inventory value
        stocks_products = pd.merge(
            self._stocks_df, self._products_df, on=["week", "seller_id", "product_id"]
        )
        stocks_products["avg_inventory_cost"] = (
            stocks_products["qty"] * stocks_products["cost"]
        )
        stocks_products["storage_cost"] = (
            stocks_products["qty"] * stocks_products["unit_storage_cost"]
        )

        # Aggregate sales data
        sales_agg = sales_products.groupby(group_columns).agg(
            margin=("margin", "sum"),
            logistic_costs=("logistic_costs", "sum"),
        ).reset_index()

        # Aggregate stocks data
        stocks_agg = stocks_products.groupby(group_columns).agg(
            avg_inventory_cost=("avg_inventory_cost", "sum"),
            storage_cost=("storage_cost", "sum"),
        ).reset_index()

        # Merge aggregated sales and stocks
        merged_df = pd.merge(sales_agg, stocks_agg, on=group_columns, how="outer").fillna(0)

        # Calculate GMROI
        merged_df["gmroi"] = (
            merged_df["margin"] - merged_df["logistic_costs"] - merged_df["storage_cost"]
        ) / merged_df["avg_inventory_cost"]
        merged_df["gmroi"] = merged_df["gmroi"].round(2)

        # Sort by week and other group columns
        merged_df = merged_df.sort_values(by=group_columns)

        return merged_df[group_columns + ["gmroi"]]

    def _process_purchases(self) -> pd.DataFrame:
        """
        Processes purchase data to calculate total weekly purchases for each category.

        Returns:
            pd.DataFrame: DataFrame with weekly purchase costs by category, containing:
                - week (str): Week of the data.
                - Category columns (int): Purchase costs for each category as separate columns.

        Sorting:
            Resulting DataFrame is sorted by `week` in ascending order.
        """
        purchases_products = pd.merge(
            self._purchases_df,
            self._products_df[self._products_df["seller_id"] == 0],
            on=["week", "product_id"],
        )
        purchases_products["purchase_cost"] = (
            purchases_products["qty"] * purchases_products["cost"]
        )

        pivot_df = purchases_products.pivot_table(
            index="week",
            columns="category_id",
            values="purchase_cost",
            aggfunc="sum",
            fill_value=0,
        ).reset_index()

        pivot_df.columns.name = None
        pivot_df = pivot_df.sort_values(by="week")

        return pivot_df

import pandas as pd
purchases_df = pd.read_csv("/content/purchases.csv")
products_df = pd.read_csv("/content/products.csv")

purchases_products = pd.merge(
        purchases_df,
        products_df[['week', 'product_id', 'category_id', 'cost']],
        on=['week', 'product_id'],
        how='left'
    )

purchases_products['purchase_cost'] = purchases_products['cost'] * purchases_products['qty']
pivot_df = purchases_products.pivot_table(
        index='week',
        columns='category_id',
        values='purchase_cost',
        aggfunc='sum',
        fill_value=0
    )
pivot_df.reset_index(inplace=True)
pivot_df.sort_values('week', inplace=True)

from tabulate import tabulate

gmroi = GMROI("products.csv", "sales.csv", "stocks.csv", "purchases.csv")

print("Weekly GMROI by seller_id:")
print(
    tabulate(
        gmroi.seller_gmroi.query('week == "2023-01-02"'),
        headers="keys",
        tablefmt="psql",
    )
)

print("Weekly GMROI by category_id:")
print(
    tabulate(
        gmroi.category_gmroi.query('week == "2023-01-02"'),
        headers="keys",
        tablefmt="psql",
    ),
)

print("Weekly purchases by category_id for seller `KarpovExpress`:")
print(
    tabulate(
        gmroi.purchases.query('week == "2023-01-02"'),
        headers="keys",
        tablefmt="psql",
    )
)

### Output:
# Weekly GMROI by seller_id:
# +----+------------+-------------+---------+
# |    | week       |   seller_id |   gmroi |
# |----+------------+-------------+---------|
# |  0 | 2023-01-02 |           0 |    1.48 |
# |  1 | 2023-01-02 |           1 |    1.29 |
# |  2 | 2023-01-02 |           2 |    1.1  |
# |  3 | 2023-01-02 |           3 |    1.17 |
# |  4 | 2023-01-02 |           4 |    1.17 |
# +----+------------+-------------+---------+

# Weekly GMROI by category_id:
# +----+------------+---------------+---------+
# |    | week       |   category_id |   gmroi |
# |----+------------+---------------+---------|
# |  0 | 2023-01-02 |             1 |    1.29 |
# |  1 | 2023-01-02 |             2 |    1.06 |
# |  2 | 2023-01-02 |             3 |    1.18 |
# |  3 | 2023-01-02 |             4 |    1.08 |
# |  4 | 2023-01-02 |             5 |    1.25 |
# |  5 | 2023-01-02 |             6 |    1.23 |
# |  6 | 2023-01-02 |             7 |    1.07 |
# |  7 | 2023-01-02 |             8 |    1.21 |
# |  8 | 2023-01-02 |             9 |    1.32 |
# |  9 | 2023-01-02 |            10 |    1.27 |
# +----+------------+---------------+---------+

# Weekly purchases by category_id for seller `KarpovExpress`:
# +----+------------+---------+---------+---------+---------+---------+
# |    | week       |       1 |       3 |       5 |       8 |       9 |
# |----+------------+---------+---------+---------+---------+---------|
# |  0 | 2023-01-02 | 5129792 | 9231286 | 4241830 | 6895368 | 7395210 |
# +----+------------+---------+---------+---------+---------+---------+

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 6))
for seller in gmroi.seller_gmroi['seller_id'].unique():
    seller_data = gmroi.seller_gmroi[gmroi.seller_gmroi['seller_id'] == seller]
    plt.plot(pd.to_datetime(seller_data['week']), seller_data['gmroi'],
             label=f'Seller {seller}', marker='o')

plt.title('Динамика GMROI по продавцам')
plt.xlabel('Неделя')
plt.ylabel('GMROI')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

plt.figure(figsize=(14, 8))
for category in sorted(gmroi.category_gmroi['category_id'].unique()):
    category_data = gmroi.category_gmroi[gmroi.category_gmroi['category_id'] == category]
    plt.plot(pd.to_datetime(category_data['week']), category_data['gmroi'],
             label=f'Category {category}', marker='o')

plt.title('Динамика GMROI по категориям товаров')
plt.xlabel('Неделя')
plt.ylabel('GMROI')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

plt.figure(figsize=(14, 8))
categories = [col for col in gmroi.purchases.columns if col != 'week']
for category in categories:
    plt.plot(pd.to_datetime(gmroi.purchases['week']), gmroi.purchases[category],
             label=f'Category {category}', marker='o')

plt.title('Динамика закупок по категориям (KarpovExpress)')
plt.xlabel('Неделя')
plt.ylabel('Сумма закупок')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""**Ваша задача — построить линейную модель, описывающую влияние закупок различных категорий товаров на GMROI для продавца KarpovExpress (seller_id == 0), и оценить вклад каждой категории в итоговый показатель GMROI.**"""

from typing import List
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.preprocessing import StandardScaler
import pandas as pd


class GMROI:
    """
    Initializes the GMROI instance by loading product, sales, stock, and purchase data
    from specified CSV files, and calculating GMROI metrics based on seller and category.
    """

    def __init__(
        self,
        products_path: str,
        sales_path: str,
        stocks_path: str,
        purchases_path: str,
    ):
        """
        Initializes GMROI instance by loading data from CSV files and processing the data.
        """
        self._products_df = self._load_csv(products_path)
        self._sales_df = self._load_csv(sales_path)
        self._stocks_df = self._load_csv(stocks_path)
        self._purchases_df = self._load_csv(purchases_path)

        self.seller_gmroi = self._process_gmroi(["week", "seller_id"])
        self.category_gmroi = self._process_gmroi(["week", "category_id"])
        self.purchases = self._process_purchases()

    def _load_csv(self, file_path: str) -> pd.DataFrame:
        """
        Loads a CSV file into a DataFrame.
        """
        try:
            return pd.read_csv(file_path)
        except FileNotFoundError:
            raise FileNotFoundError(f"File not found: {file_path}")
        except Exception as e:
            raise RuntimeError(f"Error loading file {file_path}: {e}")

    def _process_gmroi(self, group_columns: List[str]) -> pd.DataFrame:
        """
        Processes data to calculate GMROI.
        """
        valid_group_columns = [
            ["week"],
            ["week", "seller_id"],
            ["week", "category_id"],
        ]
        if group_columns not in valid_group_columns:
            raise ValueError("Invalid group_columns")

        # Merge products with sales
        sales_products = pd.merge(
            self._sales_df, self._products_df, on=["week", "seller_id", "product_id"]
        )
        sales_products["revenue"] = sales_products["qty"] * sales_products["price"]
        sales_products["cogs"] = sales_products["qty"] * sales_products["cost"]
        sales_products["margin"] = sales_products["revenue"] - sales_products["cogs"]

        # Merge with stocks
        stocks_products = pd.merge(
            self._stocks_df, self._products_df, on=["week", "seller_id", "product_id"]
        )
        stocks_products["avg_inventory_cost"] = (
            stocks_products["qty"] * stocks_products["cost"]
        )
        stocks_products["storage_cost"] = (
            stocks_products["qty"] * stocks_products["unit_storage_cost"]
        )

        # Aggregate data
        sales_agg = sales_products.groupby(group_columns).agg(
            margin=("margin", "sum"),
            logistic_costs=("logistic_costs", "sum"),
        ).reset_index()

        stocks_agg = stocks_products.groupby(group_columns).agg(
            avg_inventory_cost=("avg_inventory_cost", "sum"),
            storage_cost=("storage_cost", "sum"),
        ).reset_index()

        # Merge and calculate GMROI
        merged_df = pd.merge(sales_agg, stocks_agg, on=group_columns, how="outer").fillna(0)
        merged_df["gmroi"] = (
            merged_df["margin"] - merged_df["logistic_costs"] - merged_df["storage_cost"]
        ) / merged_df["avg_inventory_cost"]
        merged_df["gmroi"] = merged_df["gmroi"].round(2)

        return merged_df[group_columns + ["gmroi"]].sort_values(by=group_columns)

    def _process_purchases(self) -> pd.DataFrame:
        """
        Processes purchase data to calculate total weekly purchases for each category.
        """
        # Filter products for KarpovExpress
        karpov_products = self._products_df[self._products_df['seller_id'] == 0]

        # Merge purchases with products
        purchases_products = pd.merge(
            self._purchases_df,
            karpov_products,
            on=["week", "product_id"],
        )

        # Calculate purchase cost
        purchases_products["purchase_cost"] = (
            purchases_products["qty"] * purchases_products["cost"]
        )

        # Create pivot table
        pivot_df = purchases_products.pivot_table(
            index="week",
            columns="category_id",
            values="purchase_cost",
            aggfunc="sum",
            fill_value=0,
        ).reset_index()

        pivot_df.columns.name = None
        return pivot_df.sort_values(by="week").reset_index(drop=True)


class CategoryImpactEval(GMROI):
    """
    A class to evaluate the impact of purchasing strategies on GMROI across different product categories.
    """

    def __init__(
        self,
        products_path: str,
        sales_path: str,
        stocks_path: str,
        purchases_path: str,
    ):
        """
        Initializes the CategoryImpactEval class with file paths to the necessary datasets.
        """
        super().__init__(products_path, sales_path, stocks_path, purchases_path)

        # Get GMROI for KarpovExpress (seller_id = 0)
        ke_gmroi = self.seller_gmroi[self.seller_gmroi['seller_id'] == 0][['week', 'gmroi']]

        # Merge with purchases data
        self._eval_data = pd.merge(ke_gmroi, self.purchases, on='week', how='inner')

        if len(self._eval_data) == 0:
            raise ValueError("DataFrame for evaluation is empty.")

    def lin_reg_evaluate(self):
        """
        Evaluates the linear relationship between GMROI and purchasing data using linear regression.
        """
        category_columns = [col for col in self._eval_data.columns if col not in ['week', 'gmroi']]
        X = self._eval_data[category_columns]
        y = self._eval_data['gmroi']

        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)

        model = LinearRegression()
        model.fit(X_scaled, y)

        y_pred = model.predict(X_scaled)
        r2 = r2_score(y, y_pred)

        coeffs = {category: round(coef, 4) for category, coef in zip(category_columns, model.coef_)}
        coeffs["intercept"] = round(model.intercept_, 4)

        return {
            "r2_score": round(r2, 4),
            "coeffs": coeffs
        }

eval = CategoryImpactEval("products.csv", "sales.csv", "stocks.csv", "purchases.csv")

eval_results = eval.gb_evaluate()

print("Evaluation results:")
print(eval_results)

### Output:
# Evaluation results:
# {
#     "r2_score": 0.9998,
#     "feature_importances": {8: 23.2793, 9: 22.1107, 3: 18.8606, 1: 18.7533, 5: 16.9962},
# }

from tabulate import tabulate

eval = CategoryImpactEval("products.csv", "sales.csv", "stocks.csv", "purchases.csv")

print("Evaluation data sample:")
print(tabulate(eval._eval_data.head(5), headers="keys", tablefmt="psql"))

eval_results = eval.lin_reg_evaluate()

print("Evaluation results:")
print(eval_results)

### Output:
# Evaluation data sample:
# +----+------------+---------+---------+---------+---------+---------+---------+
# |    | week       |       1 |       3 |       5 |       8 |       9 |   gmroi |
# |----+------------+---------+---------+---------+---------+---------+---------|
# |  0 | 2023-01-02 | 5129792 | 9231286 | 4241830 | 6895368 | 7395210 |    1.48 |
# |  1 | 2023-01-09 | 5335607 | 8854405 | 4293261 | 6515897 | 7403186 |    1.47 |
# |  2 | 2023-01-16 | 5365183 | 9255946 | 4358336 | 6863442 | 7318687 |    1.5  |
# |  3 | 2023-01-23 | 5100669 | 8811822 | 4319159 | 6758276 | 7609039 |    1.48 |
# |  4 | 2023-01-30 | 5176119 | 8928786 | 4465304 | 6844424 | 7293296 |    1.49 |
# +----+------------+---------+---------+---------+---------+---------+---------+

# Evaluation results:
# {
#     "r2_score": 0.0402,
#     "coeffs": {
#         1: -0.002,
#         3: -0.0017,
#         5: 0.0038,
#         8: -0.0001,
#         9: -0.0051,
#         "intercept": 1.5267,
#     },
# }

!pip install catboost

from typing import List
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.preprocessing import StandardScaler
from catboost import CatBoostRegressor
import pandas as pd


class GMROI:
    """
    Initializes the GMROI instance by loading product, sales, stock, and purchase data
    from specified CSV files, and calculating GMROI metrics based on seller and category.
    """

    def __init__(
        self,
        products_path: str,
        sales_path: str,
        stocks_path: str,
        purchases_path: str,
    ):
        """
        Initializes GMROI instance by loading data from CSV files and processing the data.
        """
        self._products_df = self._load_csv(products_path)
        self._sales_df = self._load_csv(sales_path)
        self._stocks_df = self._load_csv(stocks_path)
        self._purchases_df = self._load_csv(purchases_path)

        self.seller_gmroi = self._process_gmroi(["week", "seller_id"])
        self.category_gmroi = self._process_gmroi(["week", "category_id"])
        self.purchases = self._process_purchases()

    def _load_csv(self, file_path: str) -> pd.DataFrame:
        """
        Loads a CSV file into a DataFrame.
        """
        try:
            return pd.read_csv(file_path)
        except FileNotFoundError:
            raise FileNotFoundError(f"File not found: {file_path}")
        except Exception as e:
            raise RuntimeError(f"Error loading file {file_path}: {e}")

    def _process_gmroi(self, group_columns: List[str]) -> pd.DataFrame:
        """
        Processes data to calculate GMROI.
        """
        valid_group_columns = [
            ["week"],
            ["week", "seller_id"],
            ["week", "category_id"],
        ]
        if group_columns not in valid_group_columns:
            raise ValueError("Invalid group_columns")

        # Merge products with sales
        sales_products = pd.merge(
            self._sales_df, self._products_df, on=["week", "seller_id", "product_id"]
        )
        sales_products["revenue"] = sales_products["qty"] * sales_products["price"]
        sales_products["cogs"] = sales_products["qty"] * sales_products["cost"]
        sales_products["margin"] = sales_products["revenue"] - sales_products["cogs"]

        # Merge with stocks
        stocks_products = pd.merge(
            self._stocks_df, self._products_df, on=["week", "seller_id", "product_id"]
        )
        stocks_products["avg_inventory_cost"] = (
            stocks_products["qty"] * stocks_products["cost"]
        )
        stocks_products["storage_cost"] = (
            stocks_products["qty"] * stocks_products["unit_storage_cost"]
        )

        # Aggregate data
        sales_agg = sales_products.groupby(group_columns).agg(
            margin=("margin", "sum"),
            logistic_costs=("logistic_costs", "sum"),
        ).reset_index()

        stocks_agg = stocks_products.groupby(group_columns).agg(
            avg_inventory_cost=("avg_inventory_cost", "sum"),
            storage_cost=("storage_cost", "sum"),
        ).reset_index()

        # Merge and calculate GMROI
        merged_df = pd.merge(sales_agg, stocks_agg, on=group_columns, how="outer").fillna(0)
        merged_df["gmroi"] = (
            merged_df["margin"] - merged_df["logistic_costs"] - merged_df["storage_cost"]
        ) / merged_df["avg_inventory_cost"]
        merged_df["gmroi"] = merged_df["gmroi"].round(2)

        return merged_df[group_columns + ["gmroi"]].sort_values(by=group_columns)

    def _process_purchases(self) -> pd.DataFrame:
        """
        Processes purchase data to calculate total weekly purchases for each category.
        """
        # Filter products for KarpovExpress
        karpov_products = self._products_df[self._products_df['seller_id'] == 0]

        # Merge purchases with products
        purchases_products = pd.merge(
            self._purchases_df,
            karpov_products,
            on=["week", "product_id"],
        )

        # Calculate purchase cost
        purchases_products["purchase_cost"] = (
            purchases_products["qty"] * purchases_products["cost"]
        )

        # Create pivot table
        pivot_df = purchases_products.pivot_table(
            index="week",
            columns="category_id",
            values="purchase_cost",
            aggfunc="sum",
            fill_value=0,
        ).reset_index()

        pivot_df.columns.name = None
        return pivot_df.sort_values(by="week").reset_index(drop=True)


class CategoryImpactEval(GMROI):
    """
    A class to evaluate the impact of purchasing strategies on GMROI across different product categories.
    """

    def __init__(
        self,
        products_path: str,
        sales_path: str,
        stocks_path: str,
        purchases_path: str,
    ):
        """
        Initializes the CategoryImpactEval class with file paths to the necessary datasets.
        """
        super().__init__(products_path, sales_path, stocks_path, purchases_path)

        # Get GMROI for KarpovExpress (seller_id = 0)
        ke_gmroi = self.seller_gmroi[self.seller_gmroi['seller_id'] == 0][['week', 'gmroi']]

        # Merge with purchases data
        self._eval_data = pd.merge(ke_gmroi, self.purchases, on='week', how='inner')

        if len(self._eval_data) == 0:
            raise ValueError("DataFrame for evaluation is empty.")

    def lin_reg_evaluate(self):
        """
        Evaluates the linear relationship between GMROI and purchasing data using linear regression.
        """
        # Prepare features and target
        category_columns = [col for col in self._eval_data.columns if col not in ['week', 'gmroi']]
        X = self._eval_data[category_columns]
        y = self._eval_data['gmroi']

        # Standardize features
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)

        # Fit linear regression
        model = LinearRegression()
        model.fit(X_scaled, y)

        # Predict and calculate R²
        y_pred = model.predict(X_scaled)
        r2 = r2_score(y, y_pred)

        # Get coefficients and intercept
        coeffs = {category: round(coef, 4) for category, coef in zip(category_columns, model.coef_)}
        coeffs["intercept"] = round(model.intercept_, 4)

        return {
            "r2_score": round(r2, 4),
            "coeffs": coeffs
        }

    def gb_evaluate(self):
        """
        Evaluates the impact of purchasing strategies on GMROI using the CatBoost regression model.
        """
        category_columns = [col for col in self._eval_data.columns if col not in ['week', 'gmroi']]
        X = self._eval_data[category_columns]
        y = self._eval_data['gmroi']

        model = CatBoostRegressor(random_seed=42, verbose=False)
        model.fit(X, y)

        y_pred = model.predict(X)
        r2 = r2_score(y, y_pred)

        feature_importances = model.get_feature_importance()
        importance_dict = {category: round(importance, 4)
                          for category, importance in zip(category_columns, feature_importances)}

        sorted_importances = dict(sorted(importance_dict.items(),
                                       key=lambda x: x[1],
                                       reverse=True))

        return {
            "r2_score": round(r2, 4),
            "feature_importances": sorted_importances
        }

eval = CategoryImpactEval("products.csv", "sales.csv", "stocks.csv", "purchases.csv")

eval_results = eval.gb_evaluate()

print("Evaluation results:")
print(eval_results)

### Output:
# Evaluation results:
# {
#     "r2_score": 0.9998,
#     "feature_importances": {8: 23.2793, 9: 22.1107, 3: 18.8606, 1: 18.7533, 5: 16.9962},
# }

"""Рекомендации по стратегии закупок
*  Сосредоточиться на высоко-эффективных категориях:

Закупаемые категории 1, 5, 8 и 9 показали хорошие значения GMROI, что указывает на их высокую рентабельность. Чтобы увеличить ассортимент и диверсифицировать предложения, стоит рассмотреть закупку товаров из категорий 6 и 10, так как они показали устойчивый рост GMROI на протяжении анализируемого периода. Это может помочь KarpovExpress привлечь новые сегменты покупателей и повысить общую прибыльность.
Оптимизация закупок для этих категорий может включать увеличение объема закупок, работу с более надежными поставщиками и расширение ассортимента внутри этих категорий.

Средне- и низко-эффективные категории:

Категории, демонстрирующие низкие значения GMROI (такие как категории 2, 4 и 7), требуют дополнительного анализа. Необходимо выяснить какие факторы влияют на низкую доходность этих категорий, и есть ли возможность улучшить их показатели, например, за счет снижения себестоимости или улучшения продаж.
Необходимо поддерживать баланс в закупках между высоко- и среднеэффективными категориями(3), чтобы диверсифицировать ассортимент и снизить риски. Это позволит компании избежать сильной зависимости от одной или двух категорий, даже если они показывают высокие результаты.
Рекомендации по продвижению продавцов
Поддержка высокоэффективных продавцов:

Продавец 1 демонстрирует постоянно высокое значение GMROI, что указывает на его успешную стратегию закупок и управления запасами. Рекомендуется поддерживать его стратегию, возможно, предоставляя ему дополнительные ресурсы для расширения ассортимента.
Высокоэффективным продавцам, можно предоставить приоритетное место в поисковой выдаче на платформе. Это поможет повысить видимость их товаров, увеличить объем продаж и поддерживать высокие значения GMROI.
Продвижение товаров этих продавцов в рекламных кампаниях и на главной странице платформы может способствовать привлечению дополнительного спроса.
Переоценка подхода для менее эффективных продавцов:

Продавцы 2, 3 и 4 имеют более низкие показатели GMROI, что может свидетельствовать о проблемах в стратегии закупок, логистике или продажах. Рекомендуется провести детальный анализ их ассортимента и затрат, чтобы выявить возможности для оптимизации.
Для этих продавцов можно разработать программы обучения, которые помогут им улучшить управление закупками, логистикой и стратегиями ценообразования.
Эти рекомендации помогут оптимизировать стратегию закупок и повысить эффективность каждого продавца, что, в свою очередь, улучшит общие показатели GMROI для компании.
"""