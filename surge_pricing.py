# -*- coding: utf-8 -*-
"""SURGE_PRICING.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ttQvzQBtYNWnTjRTFOWSnSsUV_CHUJFj

**Алгоритм регулирования цены доставки в моменты, когда сервис начинает не справляться с потоком заказов.**

1. Выравнивание спроса и предложения в периоды высокого спроса.

**Пропорциональный контроллер (Proportional control)**

Работу Proportional control можно представить следующим образом:

1. У нас есть цель -**нужное соотношение числа заказов и курьеров.**

2. Мы смотрим, насколько текущая ситуация отличается от цели.

3. Если разница **большая, мы сильно меняем цену**.

4. Если разница **маленькая, мы чуть-чуть меняем цену.**

5. Когда мы близко к цели, **мы почти не меняем цену.**

**PID-контроллер использует формулу с тремя частями:**

- Корректировка - на сколько мы меняем цену

- P - реакция на текущую ситуацию: разницу между целью и реальностью. То что мы разобрали на прошлом шаге.

- I - учет прошлого опыта. По сути учитывает сумму ошибок.

- D - предсказание будущего. Смотрит на скорость изменения (производную) ошибки.
"""

class PIDController:
    def __init__(self, k_p: float, k_i: float, k_d: float, set_point: float):
        self.k_p = k_p
        self.k_i = k_i
        self.k_d = k_d
        self.set_point = set_point

        self.integral_term = 0.0
        self.last_error = 0.0
        self.first_call = True

    def get_error(self, process_variable: float) -> float:
        return self.set_point - process_variable

    def get_proportional(self, error: float) -> float:
        return self.k_p * error

    def get_integral(self, error: float, dt: float) -> float:
        self.integral_term += error * dt
        return self.k_i * self.integral_term

    def get_derivative(self, error: float, dt: float) -> float:
        if self.first_call:
            derivative = 0.0
            self.first_call = False
        else:
            derivative = (error - self.last_error) / dt
        self.last_error = error
        return self.k_d * derivative

    def get_control(self, process_variable: float, dt: float) -> float:
        error = self.get_error(process_variable)
        p = self.get_proportional(error)
        i = self.get_integral(error, dt)
        d = self.get_derivative(error, dt)
        control = p + i + d
        return control